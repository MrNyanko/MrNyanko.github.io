---
layout: post
title: "Java网络编程IO"
author: "郝强"
categories: resources
tags: [resources,java based]
image: javaweb-io-0.jpeg
---

## 传统IO

在JDK1.4之前，Java的I/O是建立在流之上的，输入流读取数据，输出流写入数据，不同的流类会读/写某个特定的数据源。基于同步阻塞流在网络编程爱用I/O编写程序时，存在如下困难：

- Java的I/O是建立在流（Stream）之上的，而流是同步的，当线程请求一个流读/写一段数据是，线程会一直阻塞下去，直到有数据，数据读写完毕或者发生异常时线程才会被重新使用。

  在网络编程中，流的阻塞时间取决于对方I/O线程的处理速度和网络I/O的传输速度，导致开发程序的可靠性非常差，面对恶劣的网络环境和第三方系统时，将会出现很多问题。

- 没有数据缓冲区，I/O性能存在问题。JDK1.4以后，NIO公开了Buffer缓冲区API，真正意义上使得Java程序员可以直接控制和运用缓冲区。

- 支持的字符集有限，硬件可编码性不好。

## BIO（Block I/O）编程

1. BIO编程的基本模型时（Client/Server）模型，也就是两个进程之间进行相互通信，其中服务器提供位置（IP/PORT）信息，客户端通过连接服务器监听的位置发送求情，通过三次握手建立连接，若成功，则通过Socket进行通信，基于输入和输出流的同步阻塞式通信。
2. 升级为伪异步I/O，解决同步阻塞I/O面临的一条链路需要同一个线程处理的问题，后端改为使用一个线程池来处理多客户端的请求，由于线程池在高并发时能够复用线程，不用频繁的创建和销毁线程从而大大提升了系统的效率。

## NIO（No-Block I/O）编程

1. 缓冲区-Buffer，NIO是面向缓冲块的告诉I/O，在面向流的I/O中，可以将数据直接写入或者读取到Stream对象中，在NIO库中，所有的数据都是通过缓冲区处理的。数据是从通道读入缓冲区，从缓冲区写入到通道中的。
2. 通道-Channel，网络数据通过Channel读取和写入。通道与流不同在于通道是双向的，支持阻塞和非阻塞两种模式。Channel主要分为网络读写的SelectableChannel和用于文件操作的FileChannel。
3. 多路复用器-Selector，提供选择已经就绪的任务的能力。Selector会轮询注册在其上的Channel，如果某个Channel发生读或者写事件，这个Channel就处于就绪状态，会被Selector轮询出来，然后通过SelectionKey获取已经就绪的Channel集合，进行后续的I/O操作。一个多路复用器Selector可以同时轮询多个Channel，一个线程负责Selector的轮询，就可以接入成千上万个客户端。

## AIO（Async I/O）编程

JDK1.7发布以后，对NIO做了一些升级，被称为NIO2.0，它引入了AIO，提供了异步文件通道和异步数据通道的同步，实现了真正意义上的异步非阻塞I/O。它不需要通过多路复用器Selector对注册的通道进行轮询操作即可实现异步读写，从而简化了NIO的编程模型。它通过两种方式来获取异步操作的结果：1.通过Future类来表示异步操作的结果；2.通过执行异步操作时传入一个CompletionHandler接口的实现类作为操作完成的回调。





## BIO、NIO、AIO

- 【Java BIO】：同步并阻塞，服务器实现模式为一个连接一个线程，即客户端有连接请求时，服务器端就要启动一个线程进行处理，如果这个连接不做任何事会造成不必要的线程开销，当然可以通过线程池机制改善。
- 【Java NIO】：同步非阻塞，服务器实现模式为一个请求一个线程，即客户端发送的连接请求都会注册到多路复用器上，多路复用器轮询到连接有I/O请求时才启动一个线程进行处理。
- 【Java AIO（NIO2.0）】：异步非阻塞，服务器实现模式为一个有效请求一个线程，客户端的I/O请求都是由OS先完成了再通知服务器应用服务器去启动线程急性处理。



