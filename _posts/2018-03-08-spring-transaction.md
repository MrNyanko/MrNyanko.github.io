---
layout: post
title: "Spring事务"
author: "郝强"
categories: resources
tags: [resources,spring]
image: spring-transaction-0.jpeg
---

## 事务传播行为

传播行为级别，定义的是事务的控制范围。通俗点说，执行到某段代码时，对已存在的事务的不同处理方式。

Spring对JDBC的事务隔离级别进行了补充和扩展，并提出了种事务传播行为。

1. **PROPAGATION_REQUIRED**：需要事务处理。有则使用，无则新建。这时Spring默认的事务传播行为。该级别的特征是，如果Context中已经存在事务，那么就将当前需要使用事务的代码加入到Context的事务中去执行，如果当前Context中不存在事务，则新建一个事物执行代码。这个级别通常能满足大多数的业务场景。

2. **PROPAGATION_SUPPORTS**：支持事务处理。该级别的特性是，如果Context存在事务，则将代码加入到Context的事务中执行，如果Context中没有事务，则使用非事务的方式执行。

3. **PROPAGATION_MANDATORY**：强制要求事务。该级别的特性是，当要以事务的方式执行代码时，要求Context中必须已经存在事务，否则就会抛出异常！使用MANDATORY强制事务，可以有效地控制“必须以事务执行的代码，却忘记给它加上事务控制”这种情况发生。举个简单的例子：有一个方法，对这个方法的要求时一旦被调用，该方法就必须包含在事务中才能正常执行，那么这个方法就适合设置为PROPAGATION_MANDATORY强制事务传播行为，从而在代码层面加以控制。

4. **PROPAGATION_REQUIRES_NEW**：每次都新建一个事务。该级别的特点是，当执行到一段需要事务的代码时，先判断Context中是否已经有事务存在，如果不存在，就去新建一个事物；如果已经存在，就suspend挂起当前事务，然后穿件一个新事务去执行，直到新事务执行完毕，才会恢复先前挂起的Context事务。

5. **PROPAGATION_NOT_SUPPORTED**：不支持事务。该级别的特点是，如果发现当Context中有事务存在，则挂起该事务，然后执行逻辑代码，执行完毕后，恢复先前挂起的Context事务。这个传播行为的事务，可以缩小事务处理过程的范围。举个简单的例子，在一个事物中要调用一段非核心业务的逻辑操作1000次，如果这段逻辑放在事务中，会导致该事务的范围变大，生命周期变长，为了避免因事物范围扩大、周期变长而引发一些的实现没有考虑到的异常情况发生，可以将这段逻辑设置为NOT_SUPPORTED不支持事务传播行为。

6. **PROPAGATION_NEVER**：对事务要求更严格。不能出现事务！该级别的特点是，设置了该级别的代码，在执行前一旦发现Context中有事务存在，就会抛出Runtime异常，强制停止执行，有我无他！

7. **PROPATGATION_NESTED**：嵌套事务。该级别的特点是，如果Context中存在的事务A，就将当前代码对应的事务B加入到事务A内部，嵌套执行；如果Context中不存在事务，则新建事务执行代码。换句话说。事务A与事务B之间是父子关系，A是父，B是子。理解嵌套事务的关键点是：save point。

   父、子事务嵌套、save point的说明：

   - 父事务会在子事务进入之前创建一个save point；
   - 子事务rollback，父事务只会会滚到save point，而不会回滚整个父事务；
   - 父事务commit之前，必须先commit子事务。