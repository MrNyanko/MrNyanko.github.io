<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="3.6.2">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2018-04-04T16:03:43+08:00</updated><id>http://localhost:4000/</id><title type="html">Mr.Nyanko</title><subtitle>Hao Qiang's Bolg</subtitle><author><name>Hao Qiang</name></author><entry><title type="html">设计模式</title><link href="http://localhost:4000/resources/gof.html" rel="alternate" type="text/html" title="设计模式" /><published>2018-03-27T00:00:00+08:00</published><updated>2018-03-27T00:00:00+08:00</updated><id>http://localhost:4000/resources/gof</id><content type="html" xml:base="http://localhost:4000/resources/gof.html">&lt;p&gt;由浅入深的介绍一下Gof的23种设计模式&lt;/p&gt;

&lt;h2 id=&quot;iterator模式&quot;&gt;Iterator模式&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;Iterator模式（迭代器模式）：&lt;/strong&gt;
&lt;img src=&quot;../assets/img/gof-iterator-0.png&quot; alt=&quot;gof-iterator-0&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;「Iterator模式」&lt;/strong&gt;中登场的角色：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;Iterator（迭代器）：&lt;/strong&gt;该角色负责定义按顺序逐个遍历元素的接口（API）。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;ConcreteIterator（具体的迭代器）&lt;/strong&gt;：该角色负责实现Iterator角色所定义的接口（API）。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Aggregate（集合）：&lt;/strong&gt;该角色负责定义创建Iterator角色的接口（API）。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;ConcreteAggregate（具体的集合）：&lt;/strong&gt;该角色负责实现Aggregate角色所定义的接口（API）。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;adapter模式&quot;&gt;Adapter模式&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;Adapter模式（适配器模式）：&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;类适配器模式（使用继承的适配器）
&lt;img src=&quot;../assets/img/gof-adapter-0.png&quot; alt=&quot;gof-adapter-0&quot; /&gt;&lt;/li&gt;
  &lt;li&gt;对象适配器模式（使用委托的适配器）
&lt;img src=&quot;../assets/img/gof-adapter-1.png&quot; alt=&quot;gof-adapter-1&quot; /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;「Adapter模式」&lt;/strong&gt;中登场的角色：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;Target（对象）：&lt;/strong&gt;该角色负责定义所需的方法。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Client（请求者）：&lt;/strong&gt;该角色负责使用Target角色所定义的方法进行具体处理。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Adaptee（被适配）：&lt;/strong&gt;注意不是Adapt-er（适配）角色，而是Adapt-ee（被适配）角色。Adaptee是一个持有既定方法的角色。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Adapter（适配）：&lt;/strong&gt;Adapter模式的主人公。使用Adaptee角色的方法来满足Target角色的需求，这是Adapter模式的目的，也是Adapter的作用。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;template-method模式&quot;&gt;Template Method模式&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;Template Method模式（模版方法模式）：&lt;/strong&gt;
&lt;img src=&quot;../assets/img/gof-template_method-0.png&quot; alt=&quot;gof-template_method-0&quot; /&gt;
&lt;strong&gt;「Template Method模式」&lt;/strong&gt;中登场的角色：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;AbstractClass（抽象类）：&lt;/strong&gt;AbstractClass角色不仅负责实现模版方法，还负责声明在模版方法中所使用到的抽象方法。这些抽象方法由子类ConcreteClass角色负责实现。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;ConcreteClass（具体类）：&lt;/strong&gt;该角色负责具体实现AbstractClass角色中定义的抽象方法。这里实现的方法将会在AbstractClass角色的模版方法中被调用。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;factory-method模式&quot;&gt;Factory Method模式&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;Factory Method模式（工厂方法模式）：&lt;/strong&gt;
&lt;img src=&quot;../assets/img/gof-factory_method-0.png&quot; alt=&quot;gof-factory_method-0&quot; /&gt;
&lt;strong&gt;「Factory Method模式」&lt;/strong&gt;中登场的角色：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;Product（产品）：&lt;/strong&gt;Product角色属于框架这一方，是一个抽象类。它定义了在Factory Method模式中生成的那些实例所持有的接口（API），但具体的处理则由子类ConcreteProduct角色决定。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;Creator（创建者）：&lt;/strong&gt;Creator角色属于框架这一方，它是负责生成Product角色的抽象类，但具体的处理则由子类ConcreteCreator角色决定。&lt;/p&gt;

    &lt;p&gt;不用&lt;code class=&quot;highlighter-rouge&quot;&gt;new&lt;/code&gt;关键字来生成实例，而是调用生成实例的专用方法来生成实例，这样就可以防止父类与其他具体类的耦合。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;ConcreteProduct（具体的产品）：&lt;/strong&gt;ConcreteProduct角色属于具体加工这一方，它决定了具体的产品。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;ConcreteCreator（具体的创建者）：&lt;/strong&gt;ConcreteCreator角色属于具体加工这一方，它负责生成具体的产品。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;singleton模式&quot;&gt;Singleton模式&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;Singleton模式（单例模式）：&lt;/strong&gt;
&lt;img src=&quot;../assets/img/gof-singleton-0.png&quot; alt=&quot;gof-singleton-0&quot; /&gt;
&lt;strong&gt;「Singleton模式」&lt;/strong&gt;中登场的角色：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;Singleton（单例）：&lt;/strong&gt;在Singleton模式中，只有Singleton这一个角色。Singleton角色中有一个返回唯一实例的static方法。该方法总是会返回同一个实例。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;prototype模式&quot;&gt;Prototype模式&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;Prototype模式（原型模式）：&lt;/strong&gt;
&lt;img src=&quot;../assets/img/gof-prototype-0.png&quot; alt=&quot;gof-prototype-0&quot; /&gt;
&lt;strong&gt;「Prototype模式」&lt;/strong&gt;中登场的角色：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;Prototype（原型）：&lt;/strong&gt;Prototype角色负责定义用于复制现有实例来生成新实例的方法。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;ConcretePrototype（具体的原型）：&lt;/strong&gt;角色负责实现复制现有实例并生成新实例的方法。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Client（使用者）：&lt;/strong&gt;Client角色负责使用复制实例的方法生成新的实例。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;builder模式&quot;&gt;Builder模式&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;Builder模式（建造者模式）：&lt;/strong&gt;
&lt;img src=&quot;../assets/img/gof-builder-0.png&quot; alt=&quot;gof-builder-0&quot; /&gt;
&lt;strong&gt;「Builder模式」&lt;/strong&gt;中登场的角色：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;Builder（建造者）：&lt;/strong&gt;Builder角色负责定义用于生成实例的接口（API）。Builder角色中准备了用于生成实例的方法。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;ConcreteBuilder（具体的建造者）：&lt;/strong&gt;ConcreteBuilder角色是负责实现Builder角色的接口的类（API）。这里定义了在生成实例时实际被调用的方法。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Director（监工）：&lt;/strong&gt;Director角色负责使用Builder角色的接口（API）来生成实例。它并不依赖于ConcreteBuilder角色。为了确保不论ConcreteBuilder角色是如何被定义的，Director角色都能正常工作，它只调用在Builder角色中被定义的方法。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Client（使用者）：&lt;/strong&gt;该角色使用了Builder模式。（模式中不包含此角色）&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;abstract-factory模式&quot;&gt;Abstract Factory模式&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;Abstract Factory模式（抽象工厂模式）：&lt;/strong&gt;
&lt;img src=&quot;../assets/img/gof-abstract_factory-0.png&quot; alt=&quot;gof-abstract_factory-0&quot; /&gt;
&lt;strong&gt;「Abstract Factor模式」&lt;/strong&gt;中登场的角色：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;AbstractProduct（抽象产品）：&lt;/strong&gt;AbstractProduct角色负责定义AbstractFactory角色所生成的抽象零件和产品的接口（API）。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;AbstractFactory（抽象工厂）：&lt;/strong&gt;AbstractFactory角色负责定义用于生成抽象产品的接口（API）。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Client（委托者）：&lt;/strong&gt;Client角色仅会调用AbstractFactory角色和AbstractProduct角色的接口（API）来进行工作，对于具体零件、产品和工厂一无所知。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;ConcreteProduct（具体产品）：&lt;/strong&gt;ConcreteProduct角色负责实现AbstractProduct角色的接口（API）。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;ConcreteFactory（具体工厂）：&lt;/strong&gt;ConcreteFactory角色负责实现AbstractFactory角色的接口（API）。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;bridge模式&quot;&gt;Bridge模式&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;Bridge模式（桥接模式）：&lt;/strong&gt;
&lt;img src=&quot;../assets/img/gof-bridge-0.png&quot; alt=&quot;gof-bridge-0&quot; /&gt;
&lt;strong&gt;「Bridge模式」&lt;/strong&gt;中登场的角色：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;Abstraction（抽象化）：&lt;/strong&gt;该角色位于“类的功能层次结构“的最上层。它使用Implementor角色的方法定义了基本的功能。该角色中保存了Implementor角色的实例。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;RefinedAbstraction（改善后的抽象化）：&lt;/strong&gt;在Abstraction角色的基础上增加了新功能的角色。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Implementor（实现者）：&lt;/strong&gt;该角色位于”类的实现层次结构“的最上层。它定义了用于实现Abstraction角色的接口（API）的方法。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;ConcreteImplementor（具体实现者）：&lt;/strong&gt;该角色负责实现在Implementor角色中定义的接口（API）。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;strategy模式&quot;&gt;Strategy模式&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;Strategy模式（策略模式）：&lt;/strong&gt;
&lt;img src=&quot;../assets/img/gof-strategy-0.png&quot; alt=&quot;gof-strategy-0&quot; /&gt;
&lt;strong&gt;「Strategy模式」&lt;/strong&gt;中登场的角色：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;Strategy（策略）：&lt;/strong&gt;Strategy角色负责实现策略所必需的接口（API）。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;ConcreteStrategy（具体的策略）：&lt;/strong&gt;ConcreteStrategy角色负责实现Strategy角色的接口（API）。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Context（上下文）：&lt;/strong&gt;负责使用Strategy角色。Context角色保存了ConcreteStrategy角色的实例，并使用ConcreteStrategy角色去实现需求（总之，还是要调用Strategy角色的接口（API）。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;composite模式&quot;&gt;Composite模式&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;Composite模式（组合模式）：&lt;/strong&gt;
&lt;img src=&quot;../assets/img/gof-composite-0.png&quot; alt=&quot;gof-composite-0&quot; /&gt;
&lt;strong&gt;「Composite模式」&lt;/strong&gt;中登场的角色：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;Leaf（树叶）：&lt;/strong&gt;表示“内容”的角色。在该角色中不能放入其他对象。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Composite（复合物）：&lt;/strong&gt;表示容器的角色。可以在其中放入Leaf角色和Composite角色。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Component（组件）：&lt;/strong&gt;是Leaf角色和Composite角色具有一致性的角色。Component角色是Leaf角色和Composite角色的父类。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Client（使用者）：&lt;/strong&gt;使用Composite模式的角色。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;decorator模式&quot;&gt;Decorator模式&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;Decorator模式（装饰器模式）：&lt;/strong&gt;
&lt;img src=&quot;../assets/img/gof-decorator-0.png&quot; alt=&quot;gof-decorator-0&quot; /&gt;
&lt;strong&gt;「Decorator模式」&lt;/strong&gt;中登场的角色：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;Component（组件）：&lt;/strong&gt;增加功能的核心角色。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;ConcreteComponent（具体组件）：&lt;/strong&gt;该角色是实现了Component角色所定义的接口（API）的具体实现。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Decorator（装饰物）：&lt;/strong&gt;该角色具有与Component角色相同的接口（API）。在它内部保存了被装饰对象——Component橘色。Decorator角色知道自己要装饰的对象。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;ConcreteDecorator（具体的装饰物）：&lt;/strong&gt;该角色是具体Decorator角色。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;visitor模式&quot;&gt;Visitor模式&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;Visitor模式（访问者模式）：&lt;/strong&gt;
&lt;img src=&quot;../assets/img/gof-visitor-0.png&quot; alt=&quot;gof-visitor-0&quot; /&gt;
&lt;strong&gt;「Visitor模式」&lt;/strong&gt;中登场的角色：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;Visitor（访问者）：&lt;/strong&gt;Visitor角色负责对数据结构中每个具体的元素（ConcreteElement角色）声明一个用于访问XXXX的visit（XXXX）方法。visit（XXXX）适用于处理XXXX的方法。负责实现该方法的是ConcreteVisitor角色。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;ConcreteVisitor（具体的访问者）：&lt;/strong&gt;ConcreteVisitor角色负责实现Visitor角色所定义的接口（API）。它要实现所有的visit（XXXX）方法，即实现如何处理每个ConcreteElement角色。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Element（元素）：&lt;/strong&gt;Element角色表示Visitor角色的访问对象。它声明了接受访问者的accept方法。accept方法解搜到的参数是Visitor角色。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;ConcreteElement（具体的元素）：&lt;/strong&gt;ConcreteElement角色负责实现Element角色所定义的接口（API）。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;ObjectStructure（对象结构）：&lt;/strong&gt;ObjectStructure角色负责处理Element角色的集合。ConcreteVisitor橘色为每个Element角色都准备了处理方法。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;chain-of-responsibility模式&quot;&gt;Chain of Responsibility模式&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;Chain of Responsibility模式（责任链模式）：&lt;/strong&gt;
&lt;img src=&quot;../assets/img/gof-chain_of_responsibility-0.png&quot; alt=&quot;gof-chain_of_responsibility-0&quot; /&gt;
&lt;strong&gt;「Chain of Responsibility模式」&lt;/strong&gt;中登场的角色：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;Handler（处理者）：&lt;/strong&gt;Handler角色定义了处理请求的接口（API）。Handler角色知道“下一个处理者”是谁。如果自己无法处理，它会将请求转给“下一个处理者”。当然，“下一个处理者”也是Handler角色。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;ConcreteHandler（具体的处理者）：&lt;/strong&gt;ConcreteHandler角色是处理请求的具体角色。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Client（请求者）：&lt;/strong&gt;Client角色是向第一个ConcreteHandler角色发送请求的角色。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;facade模式&quot;&gt;Facade模式&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;Facade模式（窗口模式）：&lt;/strong&gt;
&lt;img src=&quot;../assets/img/gof-facade-0.png&quot; alt=&quot;gof-facade-0&quot; /&gt;
&lt;strong&gt;「Facade模式」&lt;/strong&gt;中登场的角色：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;Facade（窗口）：&lt;/strong&gt;Facade角色是代表构成系统的许多其他角色的“简单窗口”。Facade角色向系统外部提供高层（API）。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;构成系统的其他角色：&lt;/strong&gt;这些角色各自完成自己的工作，他们并不知道Facade角色。Facade角色调用其他角色进行工作，但是其他角色不会调用Facade角色。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Client（请求者）：&lt;/strong&gt;Client角色负责调用Facade角色（Client角色并不包含在Facade模式中）。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;mediator模式&quot;&gt;Mediator模式&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;Mediator模式（仲裁者模式）：&lt;/strong&gt;
&lt;img src=&quot;../assets/img/gof-mediator-0.png&quot; alt=&quot;gof-mediator-0&quot; /&gt;
&lt;strong&gt;「Mediator模式」&lt;/strong&gt;中登场的角色：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;Mediator（仲裁者、中介者）：&lt;/strong&gt;Mediator角色负责定义与Colleague角色进行通信和做出决定的接口（API）。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;ConcreteMediator（具体的仲裁者、中介者）：&lt;/strong&gt;ConcreteMediator角色负责实现Mediator角色的接口（API），负责实际做出决定。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Colleague（同事）：&lt;/strong&gt;Colleague角色负责定义与Mediator角色进行通信的接口（API）。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;ConcreteColleague（具体的同事）：&lt;/strong&gt;ConcreteColleague角色负责实现Colleague角色的接口（API）。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;observer模式&quot;&gt;Observer模式&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;Observer模式（观察者模式）：&lt;/strong&gt;
&lt;img src=&quot;../assets/img/gof-observer-0.png&quot; alt=&quot;gof-observer-0&quot; /&gt;
&lt;strong&gt;「Observer模式」&lt;/strong&gt;中登场的角色：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;Subject（观察对象）：&lt;/strong&gt;Subject角色表示观察对象。Subject角色定义了注册观察者和删除观察者的方法。此外，它还声明了“获取现在的状态”的方法。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;ConcreteSubject（具体的观察对象）：&lt;/strong&gt;ConcreteSubject角色表示具体的被观察对象。当自身状态发生变化后，它会通知所有已经注册的Observer角色。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Observer（观察者）：&lt;/strong&gt;Observer角色负责接收来自Subject角色的状态变化的通知。为此，他声明了update方法。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;ConcreteObserver（具体的观察者）：&lt;/strong&gt;ConcreteObserver角色表示具体的Observer。当它的update方法被调用后，会去获取需要观察的对象的最新状态。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;memento模式&quot;&gt;Memento模式&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;Memento模式（备忘录）模式：&lt;/strong&gt;
&lt;img src=&quot;../assets/img/gof-memento-0.png&quot; alt=&quot;gof-memento-0&quot; /&gt;
&lt;strong&gt;「Memento模式」&lt;/strong&gt;中登场的角色：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;Originator（生成者）：&lt;/strong&gt;Originator角色会在保存自己的最新状态时生成Memento角色。当把以前保存的Memento橘色传递给Originator角色时，它会将自己恢复至生成该Memento角色时的状态。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;Memento（备忘录）：&lt;/strong&gt;Memento角色会将Originator角色的内部信息整合在一起。在Memento角色中虽然保存了Originator角色的信息，但它不会向外部公开这些信息。&lt;/p&gt;

    &lt;p&gt;Memento角色有以下两种接口（API）&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;wide interface——宽接口（API）：Memento角色提供的“宽接口（API）”是指所有用于获取恢复对象状态的方法的集合。由于宽接口（API）会暴露所有Memento角色的内部信息，因此能够使用宽接口（API）的只有Originator角色。&lt;/li&gt;
      &lt;li&gt;narrow interface——窄接口（API）：Memento角色为外部的Caretaker角色提供了“窄接口（API）”。可以通过窄接口（API）获取的Memento角色的内部信息非常有限，因此可以有效地防止信息泄漏。&lt;/li&gt;
    &lt;/ul&gt;

    &lt;p&gt;通过对外提供以上两种接口（API），可以有效地防止对象的封装性被破坏。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;Caretaker（负责人）：&lt;/strong&gt;当Caretaker角色想要保存当前的Originator角色的状态时，会通知Originator角色。Originator角色在接收到通知后会生成Memento角色的实例并将其返回给Caretaker角色。由于以后可能会用Memento实例来将Originator恢复至原来的状态，因此Caretaker角色会一直保存Memento实例。&lt;/p&gt;

    &lt;p&gt;不过Caretaker角色只能使用Memento角色两种接口（API）中的窄接口（API），也就是说它无法访问Memento角色内部的所有信息。它只是将Originator角色生成的Memento角色当作一个黑盒子保存起来。&lt;/p&gt;

    &lt;p&gt;虽然Originator角色和Memento角色之间时强关联关系，但Caretaker角色和Memento角色之间时弱关联关系。Memento角色对Caretaker角色隐藏了自身的内部信息。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;state模式&quot;&gt;State模式&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;State模式（状态模式）：&lt;/strong&gt;
&lt;img src=&quot;../assets/img/gof-state-0.png&quot; alt=&quot;gof-state-0&quot; /&gt;
&lt;strong&gt;「State模式」&lt;/strong&gt;中登场的角色：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;State（状态）：&lt;/strong&gt;State角色表示状态，定义了根据不同状态进行不同处理的接口（API）。该接口（API）是哪些处理内容依赖于状态的方法集合。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;ConcreteState（具体状态）：&lt;/strong&gt;ConcreteState角色表示各个具体的状态，它实现了State接口。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Context（状况、前后关系、上下文）：&lt;/strong&gt;Context角色持有表示当前状态的ConcreteState角色。此外，他还定义了供外部调用者使用State模式的接口（API）。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;flyweight模式&quot;&gt;Flyweight模式&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;Flyweight模式（享元模式）：&lt;/strong&gt;
&lt;img src=&quot;../assets/img/gof-flyweight-0.png&quot; alt=&quot;gof-flyweight-0&quot; /&gt;
&lt;strong&gt;「Flyweight模式」&lt;/strong&gt;中登场的角色：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;Flyweight（轻量级）：&lt;/strong&gt;按照通常方式编写程序会导致程序变重，所以如果能够共享实例会比较好，而Flyweight角色表示的就是那些实例会被共享的类。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;FlyweightFactory（轻量级工厂）：&lt;/strong&gt;FlyweightFactory角色时生成Flyweight角色的工厂。在工厂中生成Flyweight角色可以实现共享实例。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Client（请求者）：&lt;/strong&gt;Client角色使用FlyweightFactory角色来生成Flyweight角色。（与Gof的定义有差异）&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;proxy模式&quot;&gt;Proxy模式&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;Proxy模式（代理模式）：&lt;/strong&gt;
&lt;img src=&quot;../assets/img/gof-proxy-0.png&quot; alt=&quot;gof-proxy-0&quot; /&gt;
&lt;strong&gt;「Proxy模式」&lt;/strong&gt;中登场的角色：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;Subject（主体）：&lt;/strong&gt;Subject角色定义了使Proxy角色和RealSubject角色之间具有一致性的接口。由于存在Subject角色，所以Client角色不必在意它所使用的究竟是Proxy角色还是RealSubject角色。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Proxy（代理人）：&lt;/strong&gt;Proxy角色会尽量处理来自Client角色的请求。只有当自己不能处理时，它才会将工作交给RealSubject角色。Proxy角色只有在必要时才会生成RealSubject角色。Proxy角色实现了在Subject角色中定义的接口（API）。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;RealSubject（实际的主体）：&lt;/strong&gt;“本人”RealSubject角色会在“代理人”角色无法胜任工作时出场。它与Proxy角色一样，也实现了在Subject角色中定义的接口（API）。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Client（请求者）：&lt;/strong&gt;使用Proxy模式的角色。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;command模式&quot;&gt;Command模式&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;Command模式（命令模式）：&lt;/strong&gt;
&lt;img src=&quot;../assets/img/gof-command-0.png&quot; alt=&quot;gof-command-0&quot; /&gt;
&lt;strong&gt;「Command模式」中登场的角色：&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;Command（命令）：&lt;/strong&gt;Command角色负责定义命令的接口（API）。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;ConcreteCommand（具体的命令）：&lt;/strong&gt;ConcreteCommand角色负责实现在Command角色中定义的接口（API）。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Receiver（接收者）：&lt;/strong&gt;Receiver角色是Command角色执行命令时的对象，也可以称其为命令接收者。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Client（请求者）：&lt;/strong&gt;Client角色负责生成ConcreteCommand角色并分配Receiver角色。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Invoker（发动者）：&lt;/strong&gt;Invoker角色时开始执行命令的角色，它会调用在Command角色中定义的接口（API）。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;interpreter模式&quot;&gt;Interpreter模式&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;Interpreter模式（解释器模式）：&lt;/strong&gt;
&lt;img src=&quot;../assets/img/gof-interpreter-0.png&quot; alt=&quot;gof-interpreter-0&quot; /&gt;
&lt;strong&gt;「interpreter模式」&lt;/strong&gt;中登场的角色：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;AbstractExpression（抽象表达式）：&lt;/strong&gt;AbstractExpression角色定义了语法树节点的共同接口（API）。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;TerminalExpression（终结符表达式）：&lt;/strong&gt;TerminalExpression角色对应BNF中的终结符表达式。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;NonTerminalExpression（非终结符表达式）：&lt;/strong&gt;NonTerminalExpression角色对应BNF中的非终结符表达式。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Context（文脉，上下文）：&lt;/strong&gt;Context角色为解释器进行语法解析提供了必要的信息。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Client（请求者）：&lt;/strong&gt;为了推导语法树，Client角色会调用TerminalExpression角色和NonterminalExpression角色。&lt;/li&gt;
&lt;/ul&gt;</content><author><name>郝强</name></author><category term="resources" /><category term="gof" /><summary type="html">由浅入深的介绍一下Gof的23种设计模式</summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="http://localhost:4000/gof-0.jpeg" /></entry><entry><title type="html">Java中的并发工具类</title><link href="http://localhost:4000/resources/java-concurrency-util.html" rel="alternate" type="text/html" title="Java中的并发工具类" /><published>2018-03-16T00:00:00+08:00</published><updated>2018-03-16T00:00:00+08:00</updated><id>http://localhost:4000/resources/java-concurrency-util</id><content type="html" xml:base="http://localhost:4000/resources/java-concurrency-util.html">&lt;h2 id=&quot;等待多线程完成的countdownlatch&quot;&gt;等待多线程完成的CountDownLatch&lt;/h2&gt;

&lt;p&gt;CountDownLatch允许一个或多个线程等待其他线程完成操作。&lt;/p&gt;

&lt;p&gt;CountDownLatch的构造函数一个int类型的参数作为计数器，如果你想等待N个点完成，这里就传入N。&lt;/p&gt;

&lt;h2 id=&quot;同步屏障cyclicbarrier&quot;&gt;同步屏障CyclicBarrier&lt;/h2&gt;

&lt;p&gt;CyclicBarrier的字面意思是可循环使用（Cyclic）的屏障（Barrier）。它要做的事情是，让一组线程达到一个屏障（也可以叫同步点）时被阻塞，直到最后一个线程到达屏障时，屏障才会开门，所有被屏障拦截的线程才会继续运行。&lt;/p&gt;

&lt;h2 id=&quot;cyclicbarrier和countdownlatch的区别&quot;&gt;CyclicBarrier和CountDownLatch的区别&lt;/h2&gt;

&lt;p&gt;CountDownLatch的计数器只能使用一次，而CyclicBarrier的计数器可以使用reset()方法重制。所以CyclicBarrier能处理更为复杂的业务场景。例如，如果计算发生错误，可以重置计数器，并让线程重新执行一次。&lt;/p&gt;

&lt;p&gt;CyclicBarrier还提供了其他有用的方法，比如getNumberWaiting方法可以获得CyclicBarrier阻塞的线程数量。isBroken()方法用来了解阻塞线程是否被中断。&lt;/p&gt;

&lt;h2 id=&quot;控制并发线程数的semaphore&quot;&gt;控制并发线程数的Semaphore&lt;/h2&gt;

&lt;h2 id=&quot;线程间交换数据的exchanger&quot;&gt;线程间交换数据的Exchanger&lt;/h2&gt;</content><author><name>郝强</name></author><category term="resources" /><category term="concurrency" /><summary type="html">等待多线程完成的CountDownLatch</summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="http://localhost:4000/java-concurrency-util-0.jpeg" /></entry><entry><title type="html">Spring在web容器中的启动过程</title><link href="http://localhost:4000/resources/spring-run.html" rel="alternate" type="text/html" title="Spring在web容器中的启动过程" /><published>2018-03-15T00:00:00+08:00</published><updated>2018-03-15T00:00:00+08:00</updated><id>http://localhost:4000/resources/spring-run</id><content type="html" xml:base="http://localhost:4000/resources/spring-run.html">&lt;h2 id=&quot;spring容器的启动过程是什么&quot;&gt;Spring容器的启动过程是什么？&lt;/h2&gt;
&lt;p&gt;Spring在web容器中，启动过程是Servlet容器对Spring环境的构造，初始化，装配的过程。&lt;/p&gt;

&lt;h2 id=&quot;spring的启动过程&quot;&gt;Spring的启动过程&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;通过ContextLoaderListener监听作为启动Spring的入口&lt;/strong&gt;&lt;/p&gt;

    &lt;p&gt;启动必要条件：在web.xml中配置&lt;/p&gt;

    &lt;div class=&quot;language-xml highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nt&quot;&gt;&amp;lt;listener&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;nt&quot;&gt;&amp;lt;listener-class&amp;gt;&lt;/span&gt;org.springframework.web.context.ContextLoaderListener&lt;span class=&quot;nt&quot;&gt;&amp;lt;/listener-class&amp;gt;&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;&amp;lt;/listener&amp;gt;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;

    &lt;p&gt;ContextLoaderListener(Spring中的类)继承ContextLoader（Spring中的类），并实现ServletContextListener（Servlet中的接口），ServletContextListener监听ServletContext，当容器启动时，会触发ServletContextEvent事件，该事件由ServletContextListener来处理，启动初始化ServletContext时，调用contextInitiallized方法。而ContextLoaderListener实现了ServletContextListener，所以，当容器启动时，触发ServletContextEvent事件，让ContextLoaderListener执行实现方法contextInitialized（ServletContextEvent sce）&lt;/p&gt;

    &lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;ContextLoaderListener&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;extends&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ContextLoader&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;implements&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ServletContextListener&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;contextInitialized&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ServletContextEvent&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;event&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;contextLoader&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;createContextLoader&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;contextLoader&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;contextLoader&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;contextLoader&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;initWebApplicationContext&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;event&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;getServletContext&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;());&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
    &lt;p&gt;&lt;img src=&quot;../assets/img/spring-run-1.png&quot; alt=&quot;spring-run-1&quot; /&gt;&lt;/p&gt;

    &lt;ol&gt;
      &lt;li&gt;
        &lt;p&gt;&lt;strong&gt;通过initWebApplicationContext方法来初始化WebApplicaitionContext&lt;/strong&gt;&lt;/p&gt;

        &lt;p&gt;webApplicationContext是Spring中的上下文。它的作用等同于Servlet中的ServletContext。&lt;/p&gt;

        &lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;WebApplicationContext&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;initWebApplicationContext&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ServletContext&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;servletContext&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;servletContext&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;getAttribute&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;WebApplicationContext&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;throw&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;IllegalStateException&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;
                    &lt;span class=&quot;s&quot;&gt;&quot;Cannot initialize context because there is already a root application context present - &quot;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;
                    &lt;span class=&quot;s&quot;&gt;&quot;check whether you have multiple ContextLoader* definitions in your web.xml!&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;try&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;context&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
                &lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;context&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;createWebApplicationContext&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;servletContext&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
            &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;context&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;instanceof&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ConfigurableWebApplicationContext&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
                &lt;span class=&quot;n&quot;&gt;ConfigurableWebApplicationContext&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cwac&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ConfigurableWebApplicationContext&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;context&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
                &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(!&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cwac&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;isActive&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;())&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
                    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cwac&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;getParent&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
                        &lt;span class=&quot;n&quot;&gt;ApplicationContext&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;parent&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;loadParentContext&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;servletContext&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
                        &lt;span class=&quot;n&quot;&gt;cwac&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;setParent&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;parent&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
                    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
                    &lt;span class=&quot;n&quot;&gt;configureAndRefreshWebApplicationContext&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cwac&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;servletContext&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
                &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
            &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;servletContext&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;setAttribute&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;WebApplicationContext&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;context&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;

            &lt;span class=&quot;n&quot;&gt;ClassLoader&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ccl&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Thread&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;currentThread&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;().&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;getContextClassLoader&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ccl&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ContextLoader&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;class&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;getClassLoader&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;())&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
                &lt;span class=&quot;n&quot;&gt;currentContext&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;context&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
            &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ccl&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
                &lt;span class=&quot;n&quot;&gt;currentContextPerThread&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;put&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ccl&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;context&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
            &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

            &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;logger&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;isDebugEnabled&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;())&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
                &lt;span class=&quot;n&quot;&gt;logger&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;debug&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;Published root WebApplicationContext as ServletContext attribute with name [&quot;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;
                        &lt;span class=&quot;n&quot;&gt;WebApplicationContext&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;]&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
            &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;logger&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;isInfoEnabled&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;())&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
                &lt;span class=&quot;kt&quot;&gt;long&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;elapsedTime&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;System&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;currentTimeMillis&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;startTime&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
                &lt;span class=&quot;n&quot;&gt;logger&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;info&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;Root WebApplicationContext: initialization completed in &quot;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;elapsedTime&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot; ms&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
            &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

            &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;context&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;catch&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;RuntimeException&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ex&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;logger&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;error&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;Context initialization failed&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ex&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;servletContext&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;setAttribute&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;WebApplicationContext&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ex&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;throw&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ex&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;catch&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Error&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;err&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;logger&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;error&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;Context initialization failed&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;err&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;servletContext&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;setAttribute&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;WebApplicationContext&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;err&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;throw&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;err&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;        &lt;/div&gt;

        &lt;p&gt;initWebApplicationContext(ServletContext servletContext)方法是ContextLoader中的方法。他的作用是只做一个WebApplicationContext上下文，并将这个上下文保存在servletContext中，并保存在当前ContextLoader实例中。&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;&lt;strong&gt;如何初始化WebApplicationContext&lt;/strong&gt;&lt;/p&gt;

        &lt;p&gt;上面的源码中的&lt;code class=&quot;highlighter-rouge&quot;&gt;this.context = createWebApplicationContext(servletContext);&lt;/code&gt;用来制造一个WebApplicationContext，制造的过程，依赖ServletContext。&lt;/p&gt;

        &lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;protected&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;WebApplicationContext&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;createWebApplicationContext&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ServletContext&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;sc&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;Class&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;?&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;contextClass&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;determineContextClass&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;sc&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(!&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ConfigurableWebApplicationContext&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;class&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;isAssignableFrom&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;contextClass&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;))&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;throw&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;ApplicationContextException&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;Custom context class [&quot;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;contextClass&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;getName&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;
                    &lt;span class=&quot;s&quot;&gt;&quot;] is not of type [&quot;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ConfigurableWebApplicationContext&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;class&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;getName&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;]&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ConfigurableWebApplicationContext&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;BeanUtils&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;instantiateClass&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;contextClass&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;        &lt;/div&gt;

        &lt;p&gt;通过&lt;code class=&quot;highlighter-rouge&quot;&gt;determineContextClass(ServletContext servletContext)&lt;/code&gt;方法获取需要实例化的context类的class，通过&lt;code class=&quot;highlighter-rouge&quot;&gt;BeanUtils.instantiateClass(contextClasss)&lt;/code&gt;将这个class用反射的手段实例化WebApplicationContext。&lt;/p&gt;

        &lt;p&gt;那么determineContextClass怎样来确定实例化哪个context类呢？（Spring有很多的context类实现了WebApplicationContext，当然这个context类也可以是我们自己写的，具体实例化哪个，在&lt;code class=&quot;highlighter-rouge&quot;&gt;web.xml&lt;/code&gt;中配置）&lt;/p&gt;

        &lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;protected&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Class&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;?&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;determineContextClass&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ServletContext&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;servletContext&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;contextClassName&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;servletContext&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;getInitParameter&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;CONTEXT_CLASS_PARAM&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;contextClassName&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;try&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
                &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ClassUtils&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;forName&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;contextClassName&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ClassUtils&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;getDefaultClassLoader&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;());&lt;/span&gt;
            &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;catch&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ClassNotFoundException&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ex&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
                &lt;span class=&quot;k&quot;&gt;throw&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;ApplicationContextException&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;
                        &lt;span class=&quot;s&quot;&gt;&quot;Failed to load custom context class [&quot;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;contextClassName&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;]&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ex&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
            &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;contextClassName&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;defaultStrategies&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;getProperty&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;WebApplicationContext&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;class&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;getName&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;());&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;try&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
                &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ClassUtils&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;forName&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;contextClassName&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ContextLoader&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;class&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;getClassLoader&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;());&lt;/span&gt;
            &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;catch&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ClassNotFoundException&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ex&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
                &lt;span class=&quot;k&quot;&gt;throw&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;ApplicationContextException&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;
                        &lt;span class=&quot;s&quot;&gt;&quot;Failed to load default context class [&quot;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;contextClassName&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;]&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ex&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
            &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;        &lt;/div&gt;

        &lt;p&gt;从上面的代码可以看出，先从servletContext中找我们在&lt;code class=&quot;highlighter-rouge&quot;&gt;web.xml&lt;/code&gt;中有没有配置要实例化哪个上下文context，如果配置了&lt;/p&gt;

        &lt;div class=&quot;language-xml highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nt&quot;&gt;&amp;lt;context-param&amp;gt;&lt;/span&gt;   
  &lt;span class=&quot;nt&quot;&gt;&amp;lt;param-name&amp;gt;&lt;/span&gt;contextClass&lt;span class=&quot;nt&quot;&gt;&amp;lt;/param-name&amp;gt;&lt;/span&gt;   
  &lt;span class=&quot;nt&quot;&gt;&amp;lt;param-value&amp;gt;&lt;/span&gt;rg.springframework.web.context.support.StaticWebApplicationContext&lt;span class=&quot;nt&quot;&gt;&amp;lt;/param-value&amp;gt;&lt;/span&gt;   
&lt;span class=&quot;nt&quot;&gt;&amp;lt;/context-param&amp;gt;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;        &lt;/div&gt;

        &lt;p&gt;那么实例化StaticWebApplicationContext这个上下文。注意这个地方的&lt;code class=&quot;highlighter-rouge&quot;&gt;param-name&lt;/code&gt;必须是&lt;code class=&quot;highlighter-rouge&quot;&gt;contextClass&lt;/code&gt;（约定俗成的，其实是写死的）。如果没有这个配置，那么程序会找到一个叫&lt;code class=&quot;highlighter-rouge&quot;&gt;ContextLoader.properties&lt;/code&gt;的配置文件，这个配置文件注明了一个默认的上下文：&lt;code class=&quot;highlighter-rouge&quot;&gt;XMLWebApplicationContext&lt;/code&gt;。这个&lt;code class=&quot;highlighter-rouge&quot;&gt;XMLWebApplicationContext&lt;/code&gt;实例化的过程是制造一个ResourcePatternResolver的实例，这个实例将会在后面的Srping启动过程中起到关键作用。&lt;/p&gt;
      &lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;img src=&quot;../assets/img/spring-run-2.png&quot; alt=&quot;spring-run-2&quot; /&gt;&lt;/p&gt;</content><author><name>郝强</name></author><category term="resources" /><category term="spring" /><summary type="html">Spring容器的启动过程是什么？ Spring在web容器中，启动过程是Servlet容器对Spring环境的构造，初始化，装配的过程。</summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="http://localhost:4000/spring-run-0.jpeg" /></entry><entry><title type="html">Executor框架</title><link href="http://localhost:4000/resources/java-concurrency-executor.html" rel="alternate" type="text/html" title="Executor框架" /><published>2018-03-14T00:00:00+08:00</published><updated>2018-03-14T00:00:00+08:00</updated><id>http://localhost:4000/resources/java-concurrency-executor</id><content type="html" xml:base="http://localhost:4000/resources/java-concurrency-executor.html">&lt;h2 id=&quot;executor框架简介&quot;&gt;Executor框架简介&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;Execute框架的两级调度模型&lt;/p&gt;

    &lt;p&gt;在HotSpot VM的线程模型中，Java线程（java.lang.Tread）被一对一映射为本地操作系统线程。Java线程启动时会创建一个本地操作系统线程；当该Java线程终止时，这个操作系统线程也会被回收。操作系统会调度所有线程并将它们分配给可用的CPU。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Executor框架的结构与成员&lt;/p&gt;

    &lt;ol&gt;
      &lt;li&gt;
        &lt;p&gt;Executor框架的结构&lt;/p&gt;

        &lt;ul&gt;
          &lt;li&gt;
            &lt;p&gt;任务。包括执行任务需要实现的接口：Runnable接口或Callable接口。&lt;/p&gt;
          &lt;/li&gt;
          &lt;li&gt;
            &lt;p&gt;任务的执行。包括执行机制的核心接口Executor，以及继承自Executor的ExecutorService接口。Executor框架有两个关键类实现了ExecutorService接口（TreadPoolExecutor和ScheduledThreadExecutor）。&lt;/p&gt;
          &lt;/li&gt;
          &lt;li&gt;
            &lt;p&gt;异步计算的结果。包括接口Future和实现Future接口的FutureTask类。&lt;/p&gt;

            &lt;p&gt;下面是这些接口的简介：&lt;/p&gt;
          &lt;/li&gt;
          &lt;li&gt;
            &lt;p&gt;Executor是一个接口，他是Executor的框架基础，它将任务的提交与任务的执行分离开来。&lt;/p&gt;
          &lt;/li&gt;
          &lt;li&gt;
            &lt;p&gt;ThreadPoolExecutor是线程池的核心实现类，用来执行被提交的任务。&lt;/p&gt;
          &lt;/li&gt;
          &lt;li&gt;
            &lt;p&gt;ScheduledTreadPoolExecutor是一个实现类，可以在给定的延迟后运行命令，或者定期执行命令。ScheduledTreadPoolExecutor比Timer更灵活，功能更强大。&lt;/p&gt;
          &lt;/li&gt;
          &lt;li&gt;
            &lt;p&gt;Future接口和实现Future接口的FutureTask类，代表异步计算的结果。&lt;/p&gt;
          &lt;/li&gt;
          &lt;li&gt;
            &lt;p&gt;Runnable接口和Callable接口的实现类，都可以被ThreadPoolExecutor或者ScheduledThreadPoolExecutor执行。&lt;/p&gt;
          &lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;Executor框架的成员&lt;/p&gt;

        &lt;ol&gt;
          &lt;li&gt;ThreadPoolExecutor&lt;/li&gt;
        &lt;/ol&gt;

        &lt;p&gt;ThreadPoolExecutor通常使用工厂类Executor来创建。Executors可以创建3中类型的ThreadPoolExecutor：SingleThreadExecutor、FixedThreadExecutor和CachedThreadPool。&lt;/p&gt;

        &lt;ul&gt;
          &lt;li&gt;FixedThreadPool。适用于为了满足资源管理需求，而需要限制当前线程数量的应用场景，它适用于负载比较重的服务器。&lt;/li&gt;
          &lt;li&gt;SingleThreadExecutor。适用于需要保证顺序地执行各个任务；并且在任意时间点，不会有多个线程是活动的应用场景。&lt;/li&gt;
          &lt;li&gt;CachedThreadPool。是大小无界的线程池，适用于执行很多的短期异步任务的小程序，或者是负载比较轻的服务器。&lt;/li&gt;
        &lt;/ul&gt;

        &lt;ol&gt;
          &lt;li&gt;
            &lt;p&gt;ScheduledThreadPoolExecutor&lt;/p&gt;

            &lt;ul&gt;
              &lt;li&gt;ScheduledThreadPoolExecutor。适用于需要多个后台线程执行周期任务，同时为了满足资源管理的需求而需要限制后台线程的数量的应用场景。&lt;/li&gt;
              &lt;li&gt;SingleThreadScheduledExecutor。适用于需要单个后台线程执行周期任务，同时需要保证顺序地执行各个任务的应用场景。&lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
          &lt;li&gt;
            &lt;p&gt;Future接口&lt;/p&gt;

            &lt;p&gt;Future接口和实现Future接口的FutureTask类用来表示异步的计算的结果。&lt;/p&gt;
          &lt;/li&gt;
          &lt;li&gt;
            &lt;p&gt;Runnable接口和Callable接口&lt;/p&gt;

            &lt;p&gt;Runnable接口和Callable接口的实现类，都可以被ThreadPoolExecutor或ScheduledThreadPoolExecutor执行。他们之间的区别是Runnable不会返回结果，而Callable可以返回结果。&lt;/p&gt;
          &lt;/li&gt;
        &lt;/ol&gt;
      &lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
&lt;/ol&gt;</content><author><name>郝强</name></author><category term="resources" /><category term="concurrency" /><summary type="html">Executor框架简介</summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="http://localhost:4000/java-concurrency-executor-0.jpeg" /></entry><entry><title type="html">Java中的线程池</title><link href="http://localhost:4000/resources/java-concurrency-threadpool.html" rel="alternate" type="text/html" title="Java中的线程池" /><published>2018-03-13T00:00:00+08:00</published><updated>2018-03-13T00:00:00+08:00</updated><id>http://localhost:4000/resources/java-concurrency-threadpool</id><content type="html" xml:base="http://localhost:4000/resources/java-concurrency-threadpool.html">&lt;p&gt;Java中的线程池是运用场景最多的并发框架，几乎所有需要一步或并发执行任务的程序都可以使用线程池。在开发过程中，合理使用线程池能够带来3个好处。&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;strong&gt;降低资源消耗&lt;/strong&gt;。通过重复利用已创建的线程降低线程创建和销毁造成的消耗。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;提高响应速度&lt;/strong&gt;。当任务到达时，任务可以不需要等到线程创建就能立即执行。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;提高线程的可管理性&lt;/strong&gt;。线程是稀缺资源，如果无限制地创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一分配、调优和监控。&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;线程池的实现原理&quot;&gt;线程池的实现原理&lt;/h2&gt;
&lt;p&gt;从图中可以看出，当提交一个新任务到线程池时，线程池的处理流程如下。&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;线程池判断核心线程池里的线程是否都在执行任务。如果不是，则创建一个新的工作线程来执行任务。如果线程池里的线程都在执行任务，则进入下一流程。&lt;/li&gt;
  &lt;li&gt;线程池判断工作队列是否已经满。如果工作队列没有满，则将新提交的任务存储在这个工作队列里。如果工作队列满了，则进入下一流程。&lt;/li&gt;
  &lt;li&gt;线程池判断线程池的线程是否都处于工作状态。如果没有，则创建一个新的工作线程来执行任务。如果已经满了，则交给饱和策略来处理这个任务。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;img src=&quot;../assets/img/java-concurrency-threadpool-1.png&quot; alt=&quot;java-concurrency-threadpool-1&quot; /&gt;TreadPoolExecutor执行execute方法分下面4种情况：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;如果当前运行的线程少于corePoolSize，则创建新线程来执行（&lt;em&gt;ps：这一步需要获取全局锁&lt;/em&gt;）。&lt;/li&gt;
  &lt;li&gt;如果运行的线程等于或者多于corePoolSize，则将任务加入BlockingQueue。&lt;/li&gt;
  &lt;li&gt;如果无法将任务加入BlockingQueue（队列已满），则创建新的线程来处理任务（&lt;em&gt;ps：执行这一步需要获取全局锁&lt;/em&gt;）。&lt;/li&gt;
  &lt;li&gt;如果创建新线程将使当前运行的线程超过maximumPoolSize，任务将被拒绝，并调用RejectedExecutionHandler.rejectExecution()方法。&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;线程池的使用&quot;&gt;线程池的使用&lt;/h2&gt;

&lt;p&gt;通过TreadPoolExecutor来创建线程池。&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;TreadPoolExecutor&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;corePoolSize&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;maximumPool&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;keepAliveTime&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;milliseconds&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;runnableTaskQueue&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;handler&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;创建线程池时需要输入几个参数，如下：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;corePoolSize（线程池的基本大小）&lt;/strong&gt;：当提交一个任务到线程池时，线程池会创建一个线程来执行任务，即使其他空闲的基本线程能够执行新任务也会创建线程，等到需要执行的任务数大于线程池基本大小时就不再创建。如果调用了线程池的prestartAllCoreThreads()方法，线程池会提前创建并启动所有基本线程。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;runnableTaskQueue（任务队列）&lt;/strong&gt;：用于保存等待执行的任务的阻塞队列。可以选择以下几个阻塞队列：
    &lt;ul&gt;
      &lt;li&gt;ArrayBlockingQueue：是一个基于数组结构的有界阻塞队列，此队列按FIFO原则对元素进行排序。&lt;/li&gt;
      &lt;li&gt;LinkedBlockingQueue：一个基于链表结构的阻塞队列。此队列按FIFO排序元素，吞吐量通常高于ArrayBlockingQueue。静态工厂方法Executors.newFixedTreadPool()使用了这个队列。&lt;/li&gt;
      &lt;li&gt;SynchronousQueue：一个不存储元素的阻塞队列。每个插入操作必须等到另一个线程调用移除操作，否则插入操作一只处于阻塞状态，吞吐量通常高于LinkedBlockingQueue，静态工厂方法Executors.newCachedTreadPool使用了这个队列。&lt;/li&gt;
      &lt;li&gt;PriorityBlockingQueue：一个具有优先级的无限阻塞队列。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;maximumPoolSize（线程池最大数量）&lt;/strong&gt;：线程池允许创建的最大线程数。如果队列满了，并且已创建的线程数小于最大线程数，则线程池会再创建新的线程执行任务。值得注意的是，如果使用了无界的任务队列这个参数就没什么效果了。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;TreadFactory（线程工厂）&lt;/strong&gt;：用于设置创建线程的工厂，可以通过线程工厂给每个创建出来的线程设置更有意义的名字。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;RejectExecutionHandler（饱和策略）&lt;/strong&gt;：当队列和线程池都满了，说明线程池处于饱和状态，那么必须采取一种策略处理提交的新任务。这个策略默认情况下是AbortPolicy，表示无法处理新的任务时抛出异常。&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;AbortPolicy：直接抛出异常。&lt;/li&gt;
      &lt;li&gt;CallerRunsPolicy：只用调用者所用的线程来运行任务。&lt;/li&gt;
      &lt;li&gt;DiscardOldestPolicy：丢弃队列里最近的一个任务，并执行当前任务。&lt;/li&gt;
      &lt;li&gt;DiscardPolicy：不处理，丢弃掉。&lt;/li&gt;
    &lt;/ul&gt;

    &lt;p&gt;当然也可以根据业务场景来实现RejectExecutionHandler接口自定义策略。如记录日志或持久化存储不能处理的任务。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;keepAliveTime（线程活动保持时间）&lt;/strong&gt;：线程池的工作线程空闲后，保持存活的时间。所以如果任务很多，并且每个任务执行的时间比较短，可以调大时间，提高线程的利用率。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;TimeUnit（线程活动保持时间的单位）&lt;/strong&gt;：可选的单位有（DAYS）、小时（HOURS）、分钟（MINUTES）、毫秒（MILLISECONDS）、微秒（MRCROSECONDS）和纳秒（NANOSECONDS）。&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;向线程池提交任务&quot;&gt;向线程池提交任务&lt;/h2&gt;

&lt;p&gt;可以使用两个方法向线程池提交任务，分别为execute()和submit()方法。&lt;/p&gt;

&lt;p&gt;execute()方法用于提交一个不需要返回值的任务，所以无法判断任务是否被线程池执行成功。&lt;/p&gt;

&lt;p&gt;submit()方法用于提交需要返回值的任务。线程池会返回一个future类型的对象，通过这个future对象可以判断任务是否执行成功，并且可以通过future的get()方法来获取返回值。&lt;/p&gt;

&lt;h2 id=&quot;关闭线程池&quot;&gt;关闭线程池&lt;/h2&gt;

&lt;p&gt;可以通过dialing线程池的shutdown或shutdownNow来关闭线程池。它们的原理是便利线程池中的工作线程，然后逐个调用线程的interrupt方法来中断线程，所以无法响应中断的任务可能永远无法终止。但是他们存在一定的区别，shutdownNow首先将线程池的状态设置为STOP，然后尝试停止所有的正在执行或暂停任务的线程，并返回等待执行任务的列表，而shutdown只是将线程池的状态设置成SHUTDOWN状态，然后中断所有没有正在执行任务的线程。&lt;/p&gt;

&lt;p&gt;通常调用shutdown方法来关闭线程池，如果任务不一定要执行完，可以调用shutdownNow方法。&lt;/p&gt;</content><author><name>郝强</name></author><category term="resources" /><category term="concurrency" /><summary type="html">Java中的线程池是运用场景最多的并发框架，几乎所有需要一步或并发执行任务的程序都可以使用线程池。在开发过程中，合理使用线程池能够带来3个好处。</summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="http://localhost:4000/java-concurrency-threadpool-0.jpeg" /></entry><entry><title type="html">Java并发容器和框架</title><link href="http://localhost:4000/resources/java-concurrency-collectionandfram.html" rel="alternate" type="text/html" title="Java并发容器和框架" /><published>2018-03-12T00:00:00+08:00</published><updated>2018-03-12T00:00:00+08:00</updated><id>http://localhost:4000/resources/java-concurrency-collectionandfram</id><content type="html" xml:base="http://localhost:4000/resources/java-concurrency-collectionandfram.html">&lt;h2 id=&quot;concurrenthashmap的实现原理与使用&quot;&gt;ConcurrentHashMap的实现原理与使用&lt;/h2&gt;

&lt;p&gt;ConcurrentHashMap是线程安全且高效的HashMap。&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;为什么要使用ConcurrentHashMap&lt;/strong&gt;&lt;/p&gt;

    &lt;p&gt;在并发编程中使用HashMap可能导致程序死循环。而使用线程安全的HashTable效率又非常低下，基于以上两个原因，便于有了ConcurrentHashMap登场的机会。&lt;/p&gt;

    &lt;ol&gt;
      &lt;li&gt;
        &lt;p&gt;线程不安全的HashMap&lt;/p&gt;

        &lt;p&gt;在多线程环境下，使用HashMap进行put操作会引起死循环，导致CPU利用率接近100%，所以在并发的情况下不能使用HashMap。&lt;/p&gt;

        &lt;p&gt;HashMap在并发执行put操作时会引起死循环，是因为多线程会导致HashMap的Entry链表形成环形数据结构，一旦形成环形数据结构，Entry的next节点永远不为空，就会产生死循环获取Entry。&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;效率低下的HashTable&lt;/p&gt;

        &lt;p&gt;HashTable容器使用synchronized来保证线程安全，但在线程竞争激烈的情况下HashTable的效率非常低下。因为当一个线程访问HashTable的同步方法，其他线程也访问HashTable的同步方法，会进入阻塞或轮询状态。如线程1使用put进行元素添加，线程2不但不能使用put方法添加元素，也不能使用get方法来获取元素，所以竞争越激烈效率越低。&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;ConcurrentHashMap的锁分段技术可有效提升并发访问率&lt;/p&gt;

        &lt;p&gt;HashTable容器在竞争激烈的并发环境下表现出效率低下的原因是所有访问HashTable的线程都必须竞争同一把锁，假如容器里又多把锁，每一把锁用于锁容器其中一部分数据，那么当多线程访问容器里不同数据段的数据时，线程间就不会存在锁竞争，从而可以有效提高并发访问率，这就是ConcurrentHashMap所使用的锁分段技术。首先将数据分成一段一段地存储，然后给每一段数据配一把锁，当一个线程占用锁访问其中一个段数据的时候，其他段的数据也能被其他线程访问。&lt;/p&gt;
      &lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;ConcurrentHashMap的结构&lt;/strong&gt;&lt;/p&gt;

    &lt;p&gt;通过ConcurrentHashMap的类图来分析ConcurrentHashMap的结构。
&lt;img src=&quot;../assets/img/java-concurrency-collectionandfram-1.png&quot; alt=&quot;java-concurrency-collectionandfram-1&quot; /&gt;
ConcurrentHashMap是由Segment数组结构组成。Segment是一种可重入锁（ReentrantLock），在ConcurrentHashMap里扮演锁的角色；HashEntry则用于存储健值对数据。一个ConcurrentHashMap里包含一个Segment数组。Segment结构和HashMap类似，是一种数组和链表的结构。一个Segment里包含一个HashEntry数组，每个HashEntry是一个链表结构的元素，每个segment守护着一个HashEntry数组里的元素，当对HashEntry数组的数据进行修改时，必须首先获得与它对应的Segment锁。
&lt;img src=&quot;../assets/img/java-concurrency-collectionandfram-2.png&quot; alt=&quot;java-concurrency-collectionandfram-2&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;concurrentlinkedqueue&quot;&gt;ConcurrentLinkedQueue&lt;/h2&gt;

&lt;p&gt;在并发编程中，有时候需要使用线程安全的队列。如果要实现一个线程安全的队列有两种方式：一种是使用阻塞算法，另一种是使用非阻塞算法。使用阻塞算法的队列可以用一个锁（入队和出队用同一把锁）或两个锁（入队和出队不同的锁）等方式来实现。非阻塞的实现方式则可以使用循环CAS的方式来实现。&lt;/p&gt;

&lt;p&gt;ConcurrentLinkedQueue是一个基于链接节点的无界线程安全队列，它采用先进先出的规则对节点进行排序，当我们添加一个元素的时候，它会添加到队列的尾部；当我们获取一个元素时，他会返回队列头部的元素。它采用”wait-free”算法（即CAS算法）来实现。&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;ConcurrentLinkedQueue的结构&lt;/strong&gt;&lt;/p&gt;

    &lt;p&gt;ConcurrentLinkedQueue类图如下：
&lt;img src=&quot;../assets/img/java-concurrency-collectionandfram-3.png&quot; alt=&quot;java-concurrency-collectionandfram-3&quot; /&gt;
ConcurrentLinkedQueue由head节点和tail节点组成，每个节点（Node）由节点元素（item）和指向下一个节点（next）的引用组成，节点与节点之间就是通过这个next关联起来，从而组成一张链表结构的队列。默认情况下head节点存储的元素为空，tail节点等于head节点。&lt;/p&gt;

    &lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;transient&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;volatile&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Node&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;E&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;tail&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;head&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;入队列&lt;/strong&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;出队列&lt;/strong&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;java中的阻塞队列&quot;&gt;Java中的阻塞队列&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;什么是阻塞队列&lt;/strong&gt;&lt;/p&gt;

    &lt;p&gt;阻塞队列（BlockingQueue）是一个支持两个附加操作的队列。这两个附加的操作支持阻塞的插入和移除方法。&lt;/p&gt;

    &lt;ol&gt;
      &lt;li&gt;支持阻塞的插入方法：意思是当队列满时，队列会阻塞插入元素的线程，直到队列不满。&lt;/li&gt;
      &lt;li&gt;支持阻塞的移除方法：意思是在队列为空时，获取元素的线程会等待队列变为非空。&lt;/li&gt;
    &lt;/ol&gt;

    &lt;p&gt;阻塞队列常用于生产者和消费者的场景，生产者是向队列里添加元素的线程，消费者时从队列里去元素的线程。阻塞队列就是生产者用来存放元素、消费者用来获取元素的容器。&lt;/p&gt;

    &lt;p&gt;在阻塞队列不可用时，两个附加操作提供了4中处理方式。&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;抛出异常：当队列满时，如果再往队列里插入元素，会抛出&lt;code class=&quot;highlighter-rouge&quot;&gt;IllegalStateException(&quot;Queue full&quot;)&lt;/code&gt;异常。当队列空时，从队列里取元素会抛出&lt;code class=&quot;highlighter-rouge&quot;&gt;NoSuchElementException&lt;/code&gt;异常。&lt;/li&gt;
      &lt;li&gt;返回特殊值：当往队列插入元素时，会返回元素是否插入成功，成功返回true。如果是移除方法，则是从队列里取出一个元素，如果没有则返回null。&lt;/li&gt;
      &lt;li&gt;一直阻塞：当阻塞队列满时，如果生产者线程往队列里put元素，队列会一直阻塞生产者线程，直到队列可用或者响应中断退出。当队列空时，如果消费者线程从队列里take元素，队列会阻塞住消费者线程，直到队列不为空。&lt;/li&gt;
      &lt;li&gt;超时退出：当阻塞队列满时，如果生产者线程往队列里插入元素，队列会阻塞生产者线程一段时间，如果超过了指定的时间，生产者线程就会退出。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;方法/处理方式&lt;/th&gt;
      &lt;th&gt;抛出异常&lt;/th&gt;
      &lt;th&gt;返回特殊值&lt;/th&gt;
      &lt;th&gt;一直阻塞&lt;/th&gt;
      &lt;th&gt;超时退出&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;插入方法&lt;/td&gt;
      &lt;td&gt;add(e)&lt;/td&gt;
      &lt;td&gt;offer(e)&lt;/td&gt;
      &lt;td&gt;put(e)&lt;/td&gt;
      &lt;td&gt;offer(e,time,unit)&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;移除方法&lt;/td&gt;
      &lt;td&gt;remove()&lt;/td&gt;
      &lt;td&gt;poll()&lt;/td&gt;
      &lt;td&gt;take()&lt;/td&gt;
      &lt;td&gt;poll(time, unit)&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;检查方法&lt;/td&gt;
      &lt;td&gt;element()&lt;/td&gt;
      &lt;td&gt;peek()&lt;/td&gt;
      &lt;td&gt;不可用&lt;/td&gt;
      &lt;td&gt;不可用&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;Java里的阻塞队列&lt;/strong&gt;&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;ArrayBlockingQueue：一个由数组结构组成的有界阻塞队列。&lt;/li&gt;
      &lt;li&gt;LinkedBlockingQueue：一个由链表结构组成的有界阻塞队列。&lt;/li&gt;
      &lt;li&gt;PriorityBlockingQueue：一个支持优先级排序的无界阻塞队列。&lt;/li&gt;
      &lt;li&gt;DelayQueue：一个使用优先级队列实现的无阻塞队列。&lt;/li&gt;
      &lt;li&gt;SynchronousQueue：一个不存储元素的阻塞队列。&lt;/li&gt;
      &lt;li&gt;LinkedTransferQueue：一个由链表结构组成的无界阻塞队列。&lt;/li&gt;
      &lt;li&gt;LinkedBlockingDeque：一个由链表结构组成的双向阻塞队列。&lt;/li&gt;
    &lt;/ul&gt;

    &lt;ol&gt;
      &lt;li&gt;
        &lt;p&gt;&lt;strong&gt;ArrayBlockingQueue&lt;/strong&gt;&lt;/p&gt;

        &lt;p&gt;ArrayBlockingQueue是一个用数组实现的有界阻塞队列。此队列按照先进先出（FIFO）的原则对元素进行排序。&lt;/p&gt;

        &lt;p&gt;默认情况下不保证线程公平的访问队列，所谓公平访问队列是指阻塞的线程，可以按照阻塞的先后顺序访问队列，即先阻塞线程先访问队列。非公平性是先等待的线程是非公平的，当队列可用时，阻塞的线程都可以争夺访问队列的资格，有可能先阻塞的线程最后才访问队列。为了保证公平性，通常会降低吞吐量。访问者的公平性时使用可重入锁实现的。&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;&lt;strong&gt;LinkedBlockingQueue&lt;/strong&gt;&lt;/p&gt;

        &lt;p&gt;LinkedBlockingQueue是一个用链表实现的有界阻塞队列。此队列的默认和最大长度为Integer.MAX_VALUE。此队列按照先进先出的原则对元素进行排序。&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;&lt;strong&gt;PriorityBlockingQueue&lt;/strong&gt;&lt;/p&gt;

        &lt;p&gt;PriorityBlockingQueue是一个支持优先级的无界阻塞队列。默认情况下元素采取自然顺序生序排列，也可以自定义实现compareTo()方法来指定元素的排序规则，或者初始化PriorityBlockingQueue时，指定构造参数Comparator来对元素进行排序。需要注意的是不能保证同优先级元素的顺序。&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;&lt;strong&gt;DelayQueue&lt;/strong&gt;&lt;/p&gt;

        &lt;p&gt;DelayQueue是一个支持延时获取元素的无界阻塞队列。队列使用PriorityQueue来实现。队列中的元素必须实现Delayed接口，在创建元素时可以指定多久才能从队列中获取当前元素。只有在延迟期满时才能从队列中提取元素。&lt;/p&gt;

        &lt;p&gt;DelayQueue非常有用，可以将DelayQueue运用在以下应用场景。&lt;/p&gt;

        &lt;ul&gt;
          &lt;li&gt;缓存系统的设计：可以用DelayQueue保存缓存元素的有效期，使用一个线程循环查询DelayQueue，一旦能从DelayQueue中获取元素时，表示缓存有效期到了。&lt;/li&gt;
          &lt;li&gt;定时任务调度：使用DelayQueue保存当天将会执行的任务和执行时间，一旦从DelayQueue中获取到任务就开始执行，比如TimerQueue就是使用DelayQueue实现的。&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;&lt;strong&gt;SynchronousQueue&lt;/strong&gt;&lt;/p&gt;

        &lt;p&gt;SynchronousQueue是一个不存储元素的阻塞队列。每一个put操作必须等待一个take操作，否则不能继续添加元素。&lt;/p&gt;

        &lt;p&gt;它支持公平访问队列。默认情况下线程采用非公平性策略访问队列。使用以下构造方法可以创建公平性访问的SynchronousQueue，如果设置为true，则等待线程会采用先进先出的顺序访问队列。&lt;/p&gt;

        &lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;SynchronousQueue&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;boolean&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;fair&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;){&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;transfere&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;fair&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;?&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;TransferQueue&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;TransferStack&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;        &lt;/div&gt;

        &lt;p&gt;SynchronousQueue可以看成是一个传球手，负责把生产者线程处理的数据直接传递给消费者线程。队列本身不存储任何元素，非常适合传递性场景。SynchronousQueue的吞吐量高于LinkedBlockingQueue和ArrayBlockingQueue。&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;&lt;strong&gt;LinkedTransferQueue&lt;/strong&gt;&lt;/p&gt;

        &lt;p&gt;LinkedTransferQueue是一个由链表结构组成的无界阻塞TransferQueue队列。相对于其他阻塞队列，LinkedTransferQueue多了tryTransfer和transfer方法。&lt;/p&gt;

        &lt;ul&gt;
          &lt;li&gt;
            &lt;p&gt;transfer方法&lt;/p&gt;

            &lt;p&gt;如果当前有消费者正在等待接收元素（消费者使用take()方法或带时间限制的poll()方法时），transfer方法可以把生产者传入的元素立刻transfer（传输）给消费者。如果没有消费者等待接收元素，transfer方法会将元素存放在队列的tail节点，并等到该元素被消费者消费了才返回。&lt;/p&gt;
          &lt;/li&gt;
          &lt;li&gt;
            &lt;p&gt;tryTransfer方法&lt;/p&gt;

            &lt;p&gt;tryTransfer方法是用来试探生产者传入的元素是否能直接传递给消费者。如果没有消费者等待接收元素，则返回false。和transfer方法的区别是tryTransfer方法无论消费者是否接收，方法立即返回，而transfer方法是必须等到消费者消费了才返回。&lt;/p&gt;

            &lt;p&gt;对于带有时间限制的tryTransfer(E e, long timeout, TimeUnit unit)方法，试图把生产者传入的元素直接给消费者，但是如果没有消费者消费该元素则等待指定的时间再返回，如果超时还没消费元素，则返回false，如果在超时时间内消费了元素，则返回true。&lt;/p&gt;
          &lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;&lt;strong&gt;LinkedBlockingDeque&lt;/strong&gt;&lt;/p&gt;

        &lt;p&gt;LinkedBlockingDeque是一个由链表结构组成的双向阻塞队列。所谓双向队列指的是可以从队列的两端插入和移出元素。双向队列因为多了一个操作队列的入口，在多线程同时入队时，也就减少了一半的竞争。相比其他阻塞队列，LinkedBlockingDeque多了addFirst、addLast、offerFirst、offerLast、peekFirst和peekLast等方法。以First结尾的方法，表示插入、获取（peek）或移除双端队列的第一个元素。以Last单词结尾的方法，表示插入、获取或移除双端队列的最后一个元素。另外，插入方法add等同于addList，移除方法remove等效于removeFirst。但是take方法却等同于takeFirst。在初始化LinkedBlockingDeque时可以设置容量防止其过度膨胀。另外，双向阻塞队列可以运用在”工作窃取”模式中。&lt;/p&gt;
      &lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;阻塞队列的实现原理&lt;/strong&gt;&lt;/p&gt;

    &lt;p&gt;使用通知模式实现。所谓通知模式，就是当生产者往满的队列里添加元素时会阻塞住生产者，当消费者消费了一个队列中的元素后，会通知生产者当前队列可用。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;forkjoin框架&quot;&gt;Fork/Join框架&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;什么是Fork/Join框架&lt;/strong&gt;&lt;/p&gt;

    &lt;p&gt;Fork/Join框架是Java7提供的一个用于并行执行任务的框架，是一个把大任务分割成若干个小任务，在最终汇总每个小任务结构后得到大任务结果的框架。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;工作窃取算法&lt;/strong&gt;&lt;/p&gt;

    &lt;p&gt;工作窃取（work-stealing）算法是指某个线程从其他队列里窃取任务来执行。那么，为什么需要使用工作窃取算法呢？假如我们需要做一个比较大的任务，可以把这个任务分割为若干互不依赖的子任务，为了减少线程间的竞争，把这些子任务分别放在不同的队列里，并为每个队列创建一个单独的线来执行队列里的任务，线程和队列一一对应。比如A线程负责处理A队列里的任务。但是，有的线程会先把自己队列里的任务干完，而其他线程对应的队列里还有任务等待处理。干完活儿的线程与其等着，不如去帮其他线程干活，于是它就去其他线程的队列里窃取一个任务来执行。而在这时它们会访问同一个队列，所以为了减少窃取任务线程和被窃取任务线程之间的竞争，通常会使用双端队列，被窃取任务线程永远从双端队列的头部拿任务执行，而窃取任务的线程永远从双端队列的尾部拿任务执行。&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;工作窃取算法的优点：充分利用线程进行并行计算，减少了线程间的竞争。&lt;/li&gt;
      &lt;li&gt;工作窃取算法的缺点：在某些情况下还是存在竞争，比如双端队列里只有一个任务时。并且算法会消耗了更多的系统资源，比如创建多个线程和多个双端队列。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;Fork/Join框架的设计&lt;/strong&gt;&lt;/p&gt;

    &lt;ol&gt;
      &lt;li&gt;
        &lt;p&gt;步骤1：分割任务。首先我们需要一个fork类把大任务分割成子任务，有可能任务还是很大，所以还需要不停地分割，直到分割出的子任务足够小。&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;步骤2：执行任务并合并结果。分割的子任务分别放在双端队列里，然后几个启动线程分别从双端队列里获取任务执行。子任务执行完的结果都统一放在一个队列里，启动一个线程从队列里拿数据，然后合并这些数据。&lt;/p&gt;

        &lt;p&gt;Fork/Join使用两个类来完成以上两件事情。&lt;/p&gt;

        &lt;ol&gt;
          &lt;li&gt;
            &lt;p&gt;Fork/JoinTask：我们使用ForkJoin框架，必须首先创建一个ForkJoin任务。它提供在任务中执行fork()和join()操作的机制。通常情况下，我们不需要直接继承ForkJoinTask类，只需要继承它的子类，Fork/Join框架提供了以下两个子类。&lt;/p&gt;

            &lt;ul&gt;
              &lt;li&gt;RecursiveAction：用于没有返回结果的任务。&lt;/li&gt;
              &lt;li&gt;RecursiveTask：用于有返回结果的任务。&lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
          &lt;li&gt;
            &lt;p&gt;ForkJoinPool：ForkJoinTask需要通过ForkJoinPool来执行。&lt;/p&gt;

            &lt;p&gt;任务分割出的子任务会添加到当前工作线程所维护的双端队列中，进入队列的头部。当一个工作线程的队列里暂时没有任务时，他会随机从其他工作线程的队列的尾部获取一个任务。&lt;/p&gt;
          &lt;/li&gt;
        &lt;/ol&gt;
      &lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
&lt;/ol&gt;</content><author><name>郝强</name></author><category term="resources" /><category term="concurrency" /><summary type="html">ConcurrentHashMap的实现原理与使用</summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="http://localhost:4000/java-concurrency-collectionandfram-0.jpeg" /></entry><entry><title type="html">Java中的锁</title><link href="http://localhost:4000/resources/java-concurrency-lock.html" rel="alternate" type="text/html" title="Java中的锁" /><published>2018-03-11T00:00:00+08:00</published><updated>2018-03-11T00:00:00+08:00</updated><id>http://localhost:4000/resources/java-concurrency-lock</id><content type="html" xml:base="http://localhost:4000/resources/java-concurrency-lock.html">&lt;h2 id=&quot;lock接口&quot;&gt;Lock接口&lt;/h2&gt;

&lt;p&gt;锁是用来控制多个线程访问共享资源的方式，一般来说，一个锁能够防止多个线程同时访问共享资源（但是有些锁是可以允许多个线程并发的访问共享资源，比如读写锁）。在Lock接口出现之前，Java程序是靠synchronized关键字实现锁功能的，而Java SE 5之后，并发包中新增了Lock接口（以及相关实现类）用来实现锁功能，它提供了与synchronized关键字类似的同步功能，只是在使用时需要显式地获取和释放锁。&lt;/p&gt;

&lt;p&gt;Lock接口提供的synchronized关键字不具备的主要特性&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;特性&lt;/th&gt;
      &lt;th&gt;描述&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;尝试非阻塞的获取锁&lt;/td&gt;
      &lt;td&gt;当前线程会尝试获取锁，如果这一时刻锁没有被其他线程获取到，则成功获取并持有锁&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;能被中断地获取锁&lt;/td&gt;
      &lt;td&gt;与synchronized不同，获取到锁的线程能够响应中断，当获取到锁的线程被中断时，中断异常将会被抛出，同时锁会被释放&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;超时获取锁&lt;/td&gt;
      &lt;td&gt;在指定的截止时间之前获取锁，如果截止时间到了仍旧无法获取锁，则返回&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;Lock是一个接口，它定义了锁获取和释放的基本操作&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;方法名称&lt;/th&gt;
      &lt;th&gt;描述&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;void lock()&lt;/td&gt;
      &lt;td&gt;获取锁，调用该方法当前的线程将会获取锁，当锁获取后，从该方法返回&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;void lockInterruptibly() throws InterruptedException&lt;/td&gt;
      &lt;td&gt;可中断地获取锁，和lock()方法的不同之处在于该方法会响应中断，即在锁的获取中可以中断当前线程&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;boolean tryLock()&lt;/td&gt;
      &lt;td&gt;尝试非阻塞地获取锁，调用该方法后立刻返回，如果能够返回则返回true，否则返回false&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;boolean tryLock(long time, TimeUnit unit) throws InterrupedException&lt;/td&gt;
      &lt;td&gt;超时的获取锁，当前线程在一下3种情况下会返回：1.当前线程在超时时间内获取了锁；2.当前线程在超时时间内被中断；3.超时时间结束，返回false&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;void unlock()&lt;/td&gt;
      &lt;td&gt;释放锁&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Condition newCondition()&lt;/td&gt;
      &lt;td&gt;获取等待通知组件，该组件和当前的锁绑定，当前线程只有获得了锁，才能调用该组件的wait()方法，而调用后，当前线程将释放锁&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h2 id=&quot;队列同步器&quot;&gt;队列同步器&lt;/h2&gt;

&lt;p&gt;队列同步器AbstractQueuedSynchronizer（以下简称同步器），是用来构建锁或者其他同步组件的基础框架，它使用了一个int成员变量表示同步状态，通过内置的FIFO队列来完成资源获取线程的排队工作。&lt;/p&gt;

&lt;h2 id=&quot;重入锁&quot;&gt;重入锁&lt;/h2&gt;

&lt;p&gt;重入锁ReentrantLock，顾名思义，就是支持重新进入的锁，他表示该锁能够支持一个线程对资源的重复加锁。除此之外，该锁还支持获取锁时的公平和非公平性选择。&lt;/p&gt;

&lt;p&gt;ReentrantLock虽然没能像synchronized关键字一样支持隐式的重进入，但是在调用lock()方法时，已经获取到的锁的线程，能够再次调用lock()方法获取锁而不被阻塞。&lt;/p&gt;

&lt;p&gt;ReentrantLock提供了一个构造函数，能够控制锁是否公平。&lt;/p&gt;

&lt;h2 id=&quot;读写锁&quot;&gt;读写锁&lt;/h2&gt;

&lt;p&gt;之前提到的锁基本都是排它锁，这些锁在同一时刻只允许一个线程进行访问，而读写锁在同一时刻可以允许多个读线程访问，但是在写线程访问的同时，所有的读线程和其他写线程均被阻塞。读写锁维护了一对锁，一个读锁和一个写锁，通过分离读锁和写锁，使得并发性比一般的排它锁有了很大的提升。&lt;/p&gt;

&lt;p&gt;ReentranReadWriteLock的特性&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;特性&lt;/th&gt;
      &lt;th&gt;说明&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;公平性选择&lt;/td&gt;
      &lt;td&gt;支持非公平（默认）和公平的锁获取方式，吞吐量还是非公平优于公平&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;重进入&lt;/td&gt;
      &lt;td&gt;该锁支持重进入，以读写线程为例：读线程在获取了读锁之后，能够再次获取读锁。而写线程在获取了写锁之后能够再次获取写锁，同时也可以获取读锁&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;锁降级&lt;/td&gt;
      &lt;td&gt;遵循获取写锁，获取读锁在释放写锁的次序，写锁能够降级成为读锁&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h2 id=&quot;condition接口&quot;&gt;Condition接口&lt;/h2&gt;

&lt;p&gt;任意一个Java对象，都有一组监视器方法，主要包括wait()、wait(long timeout)、notify()以及notifyAll()方法，这些方法与synchronized同步关键字配合，可以实现等待/通知模式。Condition接口也提供了类似Object的监视器方法，与Lock配合可以实现等待/通知模式，但是这两者在使用方式以及功能特性上还是有差别的。&lt;/p&gt;</content><author><name>郝强</name></author><category term="resources" /><category term="concurrency" /><summary type="html">Lock接口</summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="http://localhost:4000/java-concurrency-lock-0.jpeg" /></entry><entry><title type="html">Java并发编程基础</title><link href="http://localhost:4000/resources/java-concurrency-basic.html" rel="alternate" type="text/html" title="Java并发编程基础" /><published>2018-03-10T00:00:00+08:00</published><updated>2018-03-10T00:00:00+08:00</updated><id>http://localhost:4000/resources/java-concurrency-basic</id><content type="html" xml:base="http://localhost:4000/resources/java-concurrency-basic.html">&lt;h2 id=&quot;java内存模型的基础&quot;&gt;Java内存模型的基础&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;【&lt;strong&gt;Java内存模型的抽象结构&lt;/strong&gt;】：&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;../assets/img/java-concurrency-space-1.png&quot; alt=&quot;java-concurrency-space-1&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;【&lt;strong&gt;从源代码到指令序列的重排序&lt;/strong&gt;】：在执行程序时，为了提高性能，编译器和处理器常常会对指令做重排序。重排序分为三种类型：&lt;/p&gt;

    &lt;ol&gt;
      &lt;li&gt;编译器优化的重排序。编译器在不改变单线程程序语义的前提下，可以重新安排语句的执行顺序。&lt;/li&gt;
      &lt;li&gt;指令集并行的重排序。现代冲利器采用了指令级并行技术来将多条指令重叠执行。如果不存在数据依赖性，处理器可以改变语句对应机器指令的执行顺序。&lt;/li&gt;
      &lt;li&gt;内存系统的重排序。由于处理器使用缓存和读/写缓冲区，这使得加载和存储操作看上去可能是乱序执行&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;重排序&quot;&gt;重排序&lt;/h2&gt;

&lt;p&gt;重排序是指编译器和处理器为了优化程序性能而对指令序列进行重新排序的一种手段。&lt;/p&gt;

&lt;h2 id=&quot;顺序一致性&quot;&gt;顺序一致性&lt;/h2&gt;

&lt;p&gt;顺序一致性内存模型是一个理论参考模型，在设计的时候，处理器的内存模型和编程语言的内存模型都会以顺序一致性内存模型作为参考。&lt;/p&gt;

&lt;h2 id=&quot;volatile的内存语义&quot;&gt;volatile的内存语义&lt;/h2&gt;

&lt;h2 id=&quot;锁的内存语义&quot;&gt;锁的内存语义&lt;/h2&gt;

&lt;h2 id=&quot;final域的内存语义&quot;&gt;final域的内存语义&lt;/h2&gt;

&lt;h2 id=&quot;happens-before&quot;&gt;happens-before&lt;/h2&gt;

&lt;h2 id=&quot;双重检查锁与延迟初始化&quot;&gt;双重检查锁与延迟初始化&lt;/h2&gt;

&lt;h2 id=&quot;java内存模型综述&quot;&gt;Java内存模型综述&lt;/h2&gt;</content><author><name>郝强</name></author><category term="resources" /><category term="concurrency" /><summary type="html">Java内存模型的基础</summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="http://localhost:4000/java-concurrency-basic-0.jpeg" /></entry><entry><title type="html">Java内存模型</title><link href="http://localhost:4000/resources/java-concurrency-space.html" rel="alternate" type="text/html" title="Java内存模型" /><published>2018-03-09T00:00:00+08:00</published><updated>2018-03-09T00:00:00+08:00</updated><id>http://localhost:4000/resources/java-concurrency-space</id><content type="html" xml:base="http://localhost:4000/resources/java-concurrency-space.html">&lt;h2 id=&quot;java内存模型的基础&quot;&gt;Java内存模型的基础&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;【&lt;strong&gt;Java内存模型的抽象结构&lt;/strong&gt;】：&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;../assets/img/java-concurrency-space-1.png&quot; alt=&quot;java-concurrency-space-1&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;【&lt;strong&gt;从源代码到指令序列的重排序&lt;/strong&gt;】：在执行程序时，为了提高性能，编译器和处理器常常会对指令做重排序。重排序分为三种类型：&lt;/p&gt;

    &lt;ol&gt;
      &lt;li&gt;编译器优化的重排序。编译器在不改变单线程程序语义的前提下，可以重新安排语句的执行顺序。&lt;/li&gt;
      &lt;li&gt;指令集并行的重排序。现代冲利器采用了指令级并行技术来将多条指令重叠执行。如果不存在数据依赖性，处理器可以改变语句对应机器指令的执行顺序。&lt;/li&gt;
      &lt;li&gt;内存系统的重排序。由于处理器使用缓存和读/写缓冲区，这使得加载和存储操作看上去可能是乱序执行&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;重排序&quot;&gt;重排序&lt;/h2&gt;

&lt;p&gt;重排序是指编译器和处理器为了优化程序性能而对指令序列进行重新排序的一种手段。&lt;/p&gt;

&lt;h2 id=&quot;顺序一致性&quot;&gt;顺序一致性&lt;/h2&gt;

&lt;p&gt;顺序一致性内存模型是一个理论参考模型，在设计的时候，处理器的内存模型和编程语言的内存模型都会以顺序一致性内存模型作为参考。&lt;/p&gt;

&lt;h2 id=&quot;volatile的内存语义&quot;&gt;volatile的内存语义&lt;/h2&gt;

&lt;h2 id=&quot;锁的内存语义&quot;&gt;锁的内存语义&lt;/h2&gt;

&lt;h2 id=&quot;final域的内存语义&quot;&gt;final域的内存语义&lt;/h2&gt;

&lt;h2 id=&quot;happens-before&quot;&gt;happens-before&lt;/h2&gt;

&lt;h2 id=&quot;双重检查锁与延迟初始化&quot;&gt;双重检查锁与延迟初始化&lt;/h2&gt;

&lt;h2 id=&quot;java内存模型综述&quot;&gt;Java内存模型综述&lt;/h2&gt;</content><author><name>郝强</name></author><category term="resources" /><category term="concurrency" /><summary type="html">Java内存模型的基础</summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="http://localhost:4000/java-concurrency-space-0.jpeg" /></entry><entry><title type="html">Spring事务</title><link href="http://localhost:4000/resources/spring-transaction.html" rel="alternate" type="text/html" title="Spring事务" /><published>2018-03-08T00:00:00+08:00</published><updated>2018-03-08T00:00:00+08:00</updated><id>http://localhost:4000/resources/spring-transaction</id><content type="html" xml:base="http://localhost:4000/resources/spring-transaction.html">&lt;h2 id=&quot;事务传播行为&quot;&gt;事务传播行为&lt;/h2&gt;

&lt;p&gt;传播行为级别，定义的是事务的控制范围。通俗点说，执行到某段代码时，对已存在的事务的不同处理方式。&lt;/p&gt;

&lt;p&gt;Spring对JDBC的事务隔离级别进行了补充和扩展，并提出了种事务传播行为。&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;PROPAGATION_REQUIRED&lt;/strong&gt;：需要事务处理。有则使用，无则新建。这是Spring默认的事务传播行为。该级别的特征是，如果Context中已经存在事务，那么就将当前需要使用事务的代码加入到Context的事务中去执行，如果当前Context中不存在事务，则新建一个事物执行代码。这个级别通常能满足大多数的业务场景。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;PROPAGATION_SUPPORTS&lt;/strong&gt;：支持事务处理。该级别的特性是，如果Context存在事务，则将代码加入到Context的事务中执行，如果Context中没有事务，则使用非事务的方式执行。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;PROPAGATION_MANDATORY&lt;/strong&gt;：强制要求事务。该级别的特性是，当要以事务的方式执行代码时，要求Context中必须已经存在事务，否则就会抛出异常！使用MANDATORY强制事务，可以有效地控制“必须以事务执行的代码，却忘记给它加上事务控制”这种情况发生。举个简单的例子：有一个方法，对这个方法的要求时一旦被调用，该方法就必须包含在事务中才能正常执行，那么这个方法就适合设置为PROPAGATION_MANDATORY强制事务传播行为，从而在代码层面加以控制。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;PROPAGATION_REQUIRES_NEW&lt;/strong&gt;：每次都新建一个事务。该级别的特点是，当执行到一段需要事务的代码时，先判断Context中是否已经有事务存在，如果不存在，就去新建一个事物；如果已经存在，就suspend挂起当前事务，然后创建一个新事务去执行，直到新事务执行完毕，才会恢复先前挂起的Context事务。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;PROPAGATION_NOT_SUPPORTED&lt;/strong&gt;：不支持事务。该级别的特点是，如果发现当Context中有事务存在，则挂起该事务，然后执行逻辑代码，执行完毕后，恢复先前挂起的Context事务。这个传播行为的事务，可以缩小事务处理过程的范围。举个简单的例子，在一个事物中要调用一段非核心业务的逻辑操作1000次，如果这段逻辑放在事务中，会导致该事务的范围变大，生命周期变长，为了避免因事物范围扩大、周期变长而引发一些的实现没有考虑到的异常情况发生，可以将这段逻辑设置为NOT_SUPPORTED不支持事务传播行为。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;PROPAGATION_NEVER&lt;/strong&gt;：对事务要求更严格。不能出现事务！该级别的特点是，设置了该级别的代码，在执行前一旦发现Context中有事务存在，就会抛出Runtime异常，强制停止执行，有我无他！&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;PROPATGATION_NESTED&lt;/strong&gt;：嵌套事务。该级别的特点是，如果Context中存在的事务A，就将当前代码对应的事务B加入到事务A内部，嵌套执行；如果Context中不存在事务，则新建事务执行代码。换句话说。事务A与事务B之间是父子关系，A是父，B是子。理解嵌套事务的关键点是：save point。&lt;/p&gt;

    &lt;p&gt;父、子事务嵌套、save point的说明：&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;父事务会在子事务进入之前创建一个save point；&lt;/li&gt;
      &lt;li&gt;子事务rollback，父事务只会会滚到save point，而不会回滚整个父事务；&lt;/li&gt;
      &lt;li&gt;父事务commit之前，必须先commit子事务。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;</content><author><name>郝强</name></author><category term="resources" /><category term="spring" /><summary type="html">事务传播行为</summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="http://localhost:4000/spring-transaction-0.jpeg" /></entry></feed>