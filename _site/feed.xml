<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="3.6.2">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2018-03-20T17:27:20+08:00</updated><id>http://localhost:4000/</id><title type="html">Mr.Nyanko</title><subtitle>Hao Qiang's Bolg</subtitle><author><name>Hao Qiang</name></author><entry><title type="html">Java中的并发工具类</title><link href="http://localhost:4000/resources/java-concurrency-util.html" rel="alternate" type="text/html" title="Java中的并发工具类" /><published>2018-03-16T00:00:00+08:00</published><updated>2018-03-16T00:00:00+08:00</updated><id>http://localhost:4000/resources/java-concurrency-util</id><content type="html" xml:base="http://localhost:4000/resources/java-concurrency-util.html">&lt;h2 id=&quot;等待多线程完成的countdownlatch&quot;&gt;等待多线程完成的CountDownLatch&lt;/h2&gt;

&lt;p&gt;CountDownLatch允许一个或多个线程等待其他线程完成操作。&lt;/p&gt;

&lt;p&gt;CountDownLatch的构造函数一个int类型的参数作为计数器，如果你想等待N个点完成，这里就传入N。&lt;/p&gt;

&lt;h2 id=&quot;同步屏障cyclicbarrier&quot;&gt;同步屏障CyclicBarrier&lt;/h2&gt;

&lt;p&gt;CyclicBarrier的字面意思是可循环使用（Cyclic）的屏障（Barrier）。它要做的事情是，让一组线程达到一个屏障（也可以叫同步点）时被阻塞，直到最后一个线程到达屏障时，屏障才会开门，所有被屏障拦截的线程才会继续运行。&lt;/p&gt;

&lt;h2 id=&quot;cyclicbarrier和countdownlatch的区别&quot;&gt;CyclicBarrier和CountDownLatch的区别&lt;/h2&gt;

&lt;p&gt;CountDownLatch的计数器只能使用一次，而CyclicBarrier的计数器可以使用reset()方法重制。所以CyclicBarrier能处理更为复杂的业务场景。例如，如果计算发生错误，可以重置计数器，并让线程重新执行一次。&lt;/p&gt;

&lt;p&gt;CyclicBarrier还提供了其他有用的方法，比如getNumberWaiting方法可以获得CyclicBarrier阻塞的线程数量。isBroken()方法用来了解阻塞线程是否被中断。&lt;/p&gt;

&lt;h2 id=&quot;控制并发线程数的semaphore&quot;&gt;控制并发线程数的Semaphore&lt;/h2&gt;

&lt;h2 id=&quot;线程间交换数据的exchanger&quot;&gt;线程间交换数据的Exchanger&lt;/h2&gt;</content><author><name>郝强</name></author><category term="resources" /><category term="concurrency" /><summary type="html">等待多线程完成的CountDownLatch</summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="http://localhost:4000/java-concurrency-util-0.jpeg" /></entry><entry><title type="html">Spring在web容器中的启动过程</title><link href="http://localhost:4000/resources/spring-run.html" rel="alternate" type="text/html" title="Spring在web容器中的启动过程" /><published>2018-03-15T00:00:00+08:00</published><updated>2018-03-15T00:00:00+08:00</updated><id>http://localhost:4000/resources/spring-run</id><content type="html" xml:base="http://localhost:4000/resources/spring-run.html">&lt;h2 id=&quot;spring容器的启动过程是什么&quot;&gt;Spring容器的启动过程是什么？&lt;/h2&gt;
&lt;p&gt;Spring在web容器中，启动过程是Servlet容器对Spring环境的构造，初始化，装配的过程。&lt;/p&gt;

&lt;h2 id=&quot;spring的启动过程&quot;&gt;Spring的启动过程&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;通过ContextLoaderListener监听作为启动Spring的入口&lt;/strong&gt;&lt;/p&gt;

    &lt;p&gt;启动必要条件：在web.xml中配置&lt;/p&gt;

    &lt;div class=&quot;language-xml highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nt&quot;&gt;&amp;lt;listener&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;nt&quot;&gt;&amp;lt;listener-class&amp;gt;&lt;/span&gt;org.springframework.web.context.ContextLoaderListener&lt;span class=&quot;nt&quot;&gt;&amp;lt;/listener-class&amp;gt;&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;&amp;lt;/listener&amp;gt;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;

    &lt;p&gt;ContextLoaderListener(Spring中的类)继承ContextLoader（Spring中的类），并实现ServletContextListener（Servlet中的接口），ServletContextListener监听ServletContext，当容器启动时，会触发ServletContextEvent事件，该事件由ServletContextListener来处理，启动初始化ServletContext时，调用contextInitiallized方法。而ContextLoaderListener实现了ServletContextListener，所以，当容器启动时，触发ServletContextEvent事件，让ContextLoaderListener执行实现方法contextInitialized（ServletContextEvent sce）&lt;/p&gt;

    &lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;ContextLoaderListener&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;extends&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ContextLoader&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;implements&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ServletContextListener&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;contextInitialized&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ServletContextEvent&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;event&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;contextLoader&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;createContextLoader&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;contextLoader&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;contextLoader&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;contextLoader&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;initWebApplicationContext&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;event&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;getServletContext&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;());&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
    &lt;p&gt;&lt;img src=&quot;../assets/img/spring-run-1.png&quot; alt=&quot;spring-run-1&quot; /&gt;&lt;/p&gt;

    &lt;ol&gt;
      &lt;li&gt;
        &lt;p&gt;&lt;strong&gt;通过initWebApplicationContext方法来初始化WebApplicaitionContext&lt;/strong&gt;&lt;/p&gt;

        &lt;p&gt;webApplicationContext是Spring中的上下文。它的作用等同于Servlet中的ServletContext。&lt;/p&gt;

        &lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;WebApplicationContext&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;initWebApplicationContext&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ServletContext&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;servletContext&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;servletContext&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;getAttribute&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;WebApplicationContext&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;throw&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;IllegalStateException&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;
                    &lt;span class=&quot;s&quot;&gt;&quot;Cannot initialize context because there is already a root application context present - &quot;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;
                    &lt;span class=&quot;s&quot;&gt;&quot;check whether you have multiple ContextLoader* definitions in your web.xml!&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;try&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;context&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
                &lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;context&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;createWebApplicationContext&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;servletContext&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
            &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;context&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;instanceof&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ConfigurableWebApplicationContext&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
                &lt;span class=&quot;n&quot;&gt;ConfigurableWebApplicationContext&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cwac&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ConfigurableWebApplicationContext&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;context&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
                &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(!&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cwac&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;isActive&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;())&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
                    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cwac&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;getParent&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
                        &lt;span class=&quot;n&quot;&gt;ApplicationContext&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;parent&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;loadParentContext&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;servletContext&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
                        &lt;span class=&quot;n&quot;&gt;cwac&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;setParent&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;parent&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
                    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
                    &lt;span class=&quot;n&quot;&gt;configureAndRefreshWebApplicationContext&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cwac&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;servletContext&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
                &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
            &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;servletContext&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;setAttribute&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;WebApplicationContext&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;context&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;

            &lt;span class=&quot;n&quot;&gt;ClassLoader&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ccl&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Thread&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;currentThread&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;().&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;getContextClassLoader&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ccl&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ContextLoader&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;class&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;getClassLoader&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;())&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
                &lt;span class=&quot;n&quot;&gt;currentContext&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;context&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
            &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ccl&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
                &lt;span class=&quot;n&quot;&gt;currentContextPerThread&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;put&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ccl&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;context&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
            &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

            &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;logger&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;isDebugEnabled&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;())&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
                &lt;span class=&quot;n&quot;&gt;logger&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;debug&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;Published root WebApplicationContext as ServletContext attribute with name [&quot;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;
                        &lt;span class=&quot;n&quot;&gt;WebApplicationContext&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;]&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
            &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;logger&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;isInfoEnabled&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;())&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
                &lt;span class=&quot;kt&quot;&gt;long&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;elapsedTime&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;System&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;currentTimeMillis&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;startTime&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
                &lt;span class=&quot;n&quot;&gt;logger&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;info&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;Root WebApplicationContext: initialization completed in &quot;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;elapsedTime&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot; ms&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
            &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

            &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;context&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;catch&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;RuntimeException&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ex&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;logger&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;error&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;Context initialization failed&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ex&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;servletContext&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;setAttribute&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;WebApplicationContext&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ex&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;throw&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ex&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;catch&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Error&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;err&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;logger&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;error&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;Context initialization failed&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;err&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;servletContext&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;setAttribute&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;WebApplicationContext&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;err&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;throw&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;err&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;        &lt;/div&gt;

        &lt;p&gt;initWebApplicationContext(ServletContext servletContext)方法是ContextLoader中的方法。他的作用是只做一个WebApplicationContext上下文，并将这个上下文保存在servletContext中，并保存在当前ContextLoader实例中。&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;&lt;strong&gt;如何初始化WebApplicationContext&lt;/strong&gt;&lt;/p&gt;

        &lt;p&gt;上面的源码中的&lt;code class=&quot;highlighter-rouge&quot;&gt;this.context = createWebApplicationContext(servletContext);&lt;/code&gt;用来制造一个WebApplicationContext，制造的过程，依赖ServletContext。&lt;/p&gt;

        &lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;protected&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;WebApplicationContext&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;createWebApplicationContext&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ServletContext&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;sc&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;Class&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;?&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;contextClass&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;determineContextClass&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;sc&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(!&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ConfigurableWebApplicationContext&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;class&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;isAssignableFrom&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;contextClass&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;))&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;throw&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;ApplicationContextException&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;Custom context class [&quot;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;contextClass&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;getName&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;
                    &lt;span class=&quot;s&quot;&gt;&quot;] is not of type [&quot;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ConfigurableWebApplicationContext&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;class&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;getName&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;]&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ConfigurableWebApplicationContext&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;BeanUtils&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;instantiateClass&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;contextClass&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;        &lt;/div&gt;

        &lt;p&gt;通过&lt;code class=&quot;highlighter-rouge&quot;&gt;determineContextClass(ServletContext servletContext)&lt;/code&gt;方法获取需要实例化的context类的class，通过&lt;code class=&quot;highlighter-rouge&quot;&gt;BeanUtils.instantiateClass(contextClasss)&lt;/code&gt;将这个class用反射的手段实例化WebApplicationContext。&lt;/p&gt;

        &lt;p&gt;那么determineContextClass怎样来确定实例化哪个context类呢？（Spring有很多的context类实现了WebApplicationContext，当然这个context类也可以是我们自己写的，具体实例化哪个，在&lt;code class=&quot;highlighter-rouge&quot;&gt;web.xml&lt;/code&gt;中配置）&lt;/p&gt;

        &lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;protected&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Class&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;?&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;determineContextClass&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ServletContext&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;servletContext&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;contextClassName&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;servletContext&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;getInitParameter&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;CONTEXT_CLASS_PARAM&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;contextClassName&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;try&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
                &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ClassUtils&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;forName&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;contextClassName&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ClassUtils&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;getDefaultClassLoader&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;());&lt;/span&gt;
            &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;catch&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ClassNotFoundException&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ex&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
                &lt;span class=&quot;k&quot;&gt;throw&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;ApplicationContextException&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;
                        &lt;span class=&quot;s&quot;&gt;&quot;Failed to load custom context class [&quot;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;contextClassName&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;]&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ex&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
            &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;contextClassName&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;defaultStrategies&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;getProperty&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;WebApplicationContext&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;class&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;getName&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;());&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;try&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
                &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ClassUtils&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;forName&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;contextClassName&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ContextLoader&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;class&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;getClassLoader&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;());&lt;/span&gt;
            &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;catch&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ClassNotFoundException&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ex&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
                &lt;span class=&quot;k&quot;&gt;throw&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;ApplicationContextException&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;
                        &lt;span class=&quot;s&quot;&gt;&quot;Failed to load default context class [&quot;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;contextClassName&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;]&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ex&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
            &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;        &lt;/div&gt;

        &lt;p&gt;从上面的代码可以看出，先从servletContext中找我们在&lt;code class=&quot;highlighter-rouge&quot;&gt;web.xml&lt;/code&gt;中有没有配置要实例化哪个上下文context，如果配置了&lt;/p&gt;

        &lt;div class=&quot;language-xml highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nt&quot;&gt;&amp;lt;context-param&amp;gt;&lt;/span&gt;   
  &lt;span class=&quot;nt&quot;&gt;&amp;lt;param-name&amp;gt;&lt;/span&gt;contextClass&lt;span class=&quot;nt&quot;&gt;&amp;lt;/param-name&amp;gt;&lt;/span&gt;   
  &lt;span class=&quot;nt&quot;&gt;&amp;lt;param-value&amp;gt;&lt;/span&gt;rg.springframework.web.context.support.StaticWebApplicationContext&lt;span class=&quot;nt&quot;&gt;&amp;lt;/param-value&amp;gt;&lt;/span&gt;   
&lt;span class=&quot;nt&quot;&gt;&amp;lt;/context-param&amp;gt;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;        &lt;/div&gt;

        &lt;p&gt;那么实例化StaticWebApplicationContext这个上下文。注意这个地方的&lt;code class=&quot;highlighter-rouge&quot;&gt;param-name&lt;/code&gt;必须是&lt;code class=&quot;highlighter-rouge&quot;&gt;contextClass&lt;/code&gt;（约定俗成的，其实是写死的）。如果没有这个配置，那么程序会找到一个叫&lt;code class=&quot;highlighter-rouge&quot;&gt;ContextLoader.properties&lt;/code&gt;的配置文件，这个配置文件注明了一个默认的上下文：&lt;code class=&quot;highlighter-rouge&quot;&gt;XMLWebApplicationContext&lt;/code&gt;。这个&lt;code class=&quot;highlighter-rouge&quot;&gt;XMLWebApplicationContext&lt;/code&gt;实例化的过程是制造一个ResourcePatternResolver的实例，这个实例将会在后面的Srping启动过程中起到关键作用。&lt;/p&gt;
      &lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;img src=&quot;../assets/img/spring-run-2.png&quot; alt=&quot;spring-run-2&quot; /&gt;&lt;/p&gt;</content><author><name>郝强</name></author><category term="resources" /><category term="spring" /><summary type="html">Spring容器的启动过程是什么？ Spring在web容器中，启动过程是Servlet容器对Spring环境的构造，初始化，装配的过程。</summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="http://localhost:4000/spring-run-0.jpeg" /></entry><entry><title type="html">Executor框架</title><link href="http://localhost:4000/resources/java-concurrency-executor.html" rel="alternate" type="text/html" title="Executor框架" /><published>2018-03-14T00:00:00+08:00</published><updated>2018-03-14T00:00:00+08:00</updated><id>http://localhost:4000/resources/java-concurrency-executor</id><content type="html" xml:base="http://localhost:4000/resources/java-concurrency-executor.html">&lt;h2 id=&quot;java内存模型的基础&quot;&gt;Java内存模型的基础&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;【&lt;strong&gt;Java内存模型的抽象结构&lt;/strong&gt;】：&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;../assets/img/java-concurrency-space-1.png&quot; alt=&quot;java-concurrency-space-1&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;【&lt;strong&gt;从源代码到指令序列的重排序&lt;/strong&gt;】：在执行程序时，为了提高性能，编译器和处理器常常会对指令做重排序。重排序分为三种类型：&lt;/p&gt;

    &lt;ol&gt;
      &lt;li&gt;编译器优化的重排序。编译器在不改变单线程程序语义的前提下，可以重新安排语句的执行顺序。&lt;/li&gt;
      &lt;li&gt;指令集并行的重排序。现代冲利器采用了指令级并行技术来将多条指令重叠执行。如果不存在数据依赖性，处理器可以改变语句对应机器指令的执行顺序。&lt;/li&gt;
      &lt;li&gt;内存系统的重排序。由于处理器使用缓存和读/写缓冲区，这使得加载和存储操作看上去可能是乱序执行&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;重排序&quot;&gt;重排序&lt;/h2&gt;

&lt;p&gt;重排序是指编译器和处理器为了优化程序性能而对指令序列进行重新排序的一种手段。&lt;/p&gt;

&lt;h2 id=&quot;顺序一致性&quot;&gt;顺序一致性&lt;/h2&gt;

&lt;p&gt;顺序一致性内存模型是一个理论参考模型，在设计的时候，处理器的内存模型和编程语言的内存模型都会以顺序一致性内存模型作为参考。&lt;/p&gt;

&lt;h2 id=&quot;volatile的内存语义&quot;&gt;volatile的内存语义&lt;/h2&gt;

&lt;h2 id=&quot;锁的内存语义&quot;&gt;锁的内存语义&lt;/h2&gt;

&lt;h2 id=&quot;final域的内存语义&quot;&gt;final域的内存语义&lt;/h2&gt;

&lt;h2 id=&quot;happens-before&quot;&gt;happens-before&lt;/h2&gt;

&lt;h2 id=&quot;双重检查锁与延迟初始化&quot;&gt;双重检查锁与延迟初始化&lt;/h2&gt;

&lt;h2 id=&quot;java内存模型综述&quot;&gt;Java内存模型综述&lt;/h2&gt;</content><author><name>郝强</name></author><category term="resources" /><category term="concurrency" /><summary type="html">Java内存模型的基础</summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="http://localhost:4000/java-concurrency-executor-0.jpeg" /></entry><entry><title type="html">Java中的线程池</title><link href="http://localhost:4000/resources/java-concurrency-threadpool.html" rel="alternate" type="text/html" title="Java中的线程池" /><published>2018-03-13T00:00:00+08:00</published><updated>2018-03-13T00:00:00+08:00</updated><id>http://localhost:4000/resources/java-concurrency-threadpool</id><content type="html" xml:base="http://localhost:4000/resources/java-concurrency-threadpool.html">&lt;p&gt;Java中的线程池是运用场景最多的并发框架，几乎所有需要一步或并发执行任务的程序都可以使用线程池。在开发过程中，合理使用线程池能够带来3个好处。&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;strong&gt;降低资源消耗&lt;/strong&gt;。通过重复利用已创建的线程降低线程创建和销毁造成的消耗。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;提高响应速度&lt;/strong&gt;。当任务到达时，任务可以不需要等到线程创建就能立即执行。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;提高线程的可管理性&lt;/strong&gt;。线程是稀缺资源，如果无限制地创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一分配、调优和监控。&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;线程池的实现原理&quot;&gt;线程池的实现原理&lt;/h2&gt;
&lt;p&gt;从图中可以看出，当提交一个新任务到线程池时，线程池的处理流程如下。&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;线程池判断核心线程池里的线程是否都在执行任务。如果不是，则创建一个新的工作线程来执行任务。如果线程池里的线程都在执行任务，则进入下一流程。&lt;/li&gt;
  &lt;li&gt;线程池判断工作队列是否已经满。如果工作队列没有满，则将新提交的任务存储在这个工作队列里。如果工作队列满了，则进入下一流程。&lt;/li&gt;
  &lt;li&gt;线程池判断线程池的线程是否都处于工作状态。如果没有，则创建一个新的工作线程来执行任务。如果已经满了，则交给饱和策略来处理这个任务。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;img src=&quot;../assets/img/java-concurrency-threadpool-1.png&quot; alt=&quot;java-concurrency-threadpool-1&quot; /&gt;TreadPoolExecutor执行execute方法分下面4种情况：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;如果当前运行的线程少于corePoolSize，则创建新线程来执行（&lt;em&gt;ps：这一步需要获取全局锁&lt;/em&gt;）。&lt;/li&gt;
  &lt;li&gt;如果运行的线程等于或者多于corePoolSize，则将任务加入BlockingQueue。&lt;/li&gt;
  &lt;li&gt;如果无法将任务加入BlockingQueue（队列已满），则创建新的线程来处理任务（&lt;em&gt;ps：执行这一步需要获取全局锁&lt;/em&gt;）。&lt;/li&gt;
  &lt;li&gt;如果创建新线程将使当前运行的线程超过maximumPoolSize，任务将被拒绝，并调用RejectedExecutionHandler.rejectExecution()方法。&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;线程池的使用&quot;&gt;线程池的使用&lt;/h2&gt;

&lt;p&gt;通过TreadPoolExecutor来创建线程池。&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;TreadPoolExecutor&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;corePoolSize&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;maximumPool&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;keepAliveTime&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;milliseconds&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;runnableTaskQueue&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;handler&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;创建线程池时需要输入几个参数，如下：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;corePoolSize（线程池的基本大小）&lt;/strong&gt;：当提交一个任务到线程池时，线程池会创建一个线程来执行任务，即使其他空闲的基本线程能够执行新任务也会创建线程，等到需要执行的任务数大于线程池基本大小时就不再创建。如果调用了线程池的prestartAllCoreThreads()方法，线程池会提前创建并启动所有基本线程。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;runnableTaskQueue（任务队列）&lt;/strong&gt;：用于保存等待执行的任务的阻塞队列。可以选择以下几个阻塞队列：
    &lt;ul&gt;
      &lt;li&gt;ArrayBlockingQueue：是一个基于数组结构的有界阻塞队列，此队列按FIFO原则对元素进行排序。&lt;/li&gt;
      &lt;li&gt;LinkedBlockingQueue：一个基于链表结构的阻塞队列。此队列按FIFO排序元素，吞吐量通常高于ArrayBlockingQueue。静态工厂方法Executors.newFixedTreadPool()使用了这个队列。&lt;/li&gt;
      &lt;li&gt;SynchronousQueue：一个不存储元素的阻塞队列。每个插入操作必须等到另一个线程调用移除操作，否则插入操作一只处于阻塞状态，吞吐量通常高于LinkedBlockingQueue，静态工厂方法Executors.newCachedTreadPool使用了这个队列。&lt;/li&gt;
      &lt;li&gt;PriorityBlockingQueue：一个具有优先级的无限阻塞队列。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;maximumPoolSize（线程池最大数量）&lt;/strong&gt;：线程池允许创建的最大线程数。如果队列满了，并且已创建的线程数小于最大线程数，则线程池会再创建新的线程执行任务。值得注意的是，如果使用了无界的任务队列这个参数就没什么效果了。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;TreadFactory（线程工厂）&lt;/strong&gt;：用于设置创建线程的工厂，可以通过线程工厂给每个创建出来的线程设置更有意义的名字。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;RejectExecutionHandler（饱和策略）&lt;/strong&gt;：当队列和线程池都满了，说明线程池处于饱和状态，那么必须采取一种策略处理提交的新任务。这个策略默认情况下是AbortPolicy，表示无法处理新的任务时抛出异常。&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;AbortPolicy：直接抛出异常。&lt;/li&gt;
      &lt;li&gt;CallerRunsPolicy：只用调用者所用的线程来运行任务。&lt;/li&gt;
      &lt;li&gt;DiscardOldestPolicy：丢弃队列里最近的一个任务，并执行当前任务。&lt;/li&gt;
      &lt;li&gt;DiscardPolicy：不处理，丢弃掉。&lt;/li&gt;
    &lt;/ul&gt;

    &lt;p&gt;当然也可以根据业务场景来实现RejectExecutionHandler接口自定义策略。如记录日志或持久化存储不能处理的任务。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;keepAliveTime（线程活动保持时间）&lt;/strong&gt;：线程池的工作线程空闲后，保持存活的时间。所以如果任务很多，并且每个任务执行的时间比较短，可以调大时间，提高线程的利用率。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;TimeUnit（线程活动保持时间的单位）&lt;/strong&gt;：可选的单位有（DAYS）、小时（HOURS）、分钟（MINUTES）、毫秒（MILLISECONDS）、微秒（MRCROSECONDS）和纳秒（NANOSECONDS）。&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;向线程池提交任务&quot;&gt;向线程池提交任务&lt;/h2&gt;

&lt;p&gt;可以使用两个方法向线程池提交任务，分别为execute()和submit()方法。&lt;/p&gt;

&lt;p&gt;execute()方法用于提交一个不需要返回值的任务，所以无法判断任务是否被线程池执行成功。&lt;/p&gt;

&lt;p&gt;submit()方法用于提交需要返回值的任务。线程池会返回一个future类型的对象，通过这个future对象可以判断任务是否执行成功，并且可以通过future的get()方法来获取返回值。&lt;/p&gt;

&lt;h2 id=&quot;关闭线程池&quot;&gt;关闭线程池&lt;/h2&gt;

&lt;p&gt;可以通过dialing线程池的shutdown或shutdownNow来关闭线程池。它们的原理是便利线程池中的工作线程，然后逐个调用线程的interrupt方法来中断线程，所以无法响应中断的任务可能永远无法终止。但是他们存在一定的区别，shutdownNow首先将线程池的状态设置为STOP，然后尝试停止所有的正在执行或暂停任务的线程，并返回等待执行任务的列表，而shutdown只是将线程池的状态设置成SHUTDOWN状态，然后中断所有没有正在执行任务的线程。&lt;/p&gt;

&lt;p&gt;通常调用shutdown方法来关闭线程池，如果任务不一定要执行完，可以调用shutdownNow方法。&lt;/p&gt;</content><author><name>郝强</name></author><category term="resources" /><category term="concurrency" /><summary type="html">Java中的线程池是运用场景最多的并发框架，几乎所有需要一步或并发执行任务的程序都可以使用线程池。在开发过程中，合理使用线程池能够带来3个好处。</summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="http://localhost:4000/java-concurrency-threadpool-0.jpeg" /></entry><entry><title type="html">Java并发容器和框架</title><link href="http://localhost:4000/resources/java-concurrency-collectionandfram.html" rel="alternate" type="text/html" title="Java并发容器和框架" /><published>2018-03-12T00:00:00+08:00</published><updated>2018-03-12T00:00:00+08:00</updated><id>http://localhost:4000/resources/java-concurrency-collectionandfram</id><content type="html" xml:base="http://localhost:4000/resources/java-concurrency-collectionandfram.html">&lt;h2 id=&quot;concurrenthashmap的实现原理与使用&quot;&gt;ConcurrentHashMap的实现原理与使用&lt;/h2&gt;

&lt;p&gt;ConcurrentHashMap是线程安全且高效的HashMap。&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;为什么要使用ConcurrentHashMap&lt;/strong&gt;&lt;/p&gt;

    &lt;p&gt;在并发编程中使用HashMap可能导致程序死循环。而使用线程安全的HashTable效率又非常低下，基于以上两个原因，便于有了ConcurrentHashMap登场的机会。&lt;/p&gt;

    &lt;ol&gt;
      &lt;li&gt;
        &lt;p&gt;线程不安全的HashMap&lt;/p&gt;

        &lt;p&gt;在多线程环境下，使用HashMap进行put操作会引起死循环，导致CPU利用率接近100%，所以在并发的情况下不能使用HashMap。&lt;/p&gt;

        &lt;p&gt;HashMap在并发执行put操作时会引起死循环，是因为多线程会导致HashMap的Entry链表形成环形数据结构，一旦形成环形数据结构，Entry的next节点永远不为空，就会产生死循环获取Entry。&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;效率低下的HashTable&lt;/p&gt;

        &lt;p&gt;HashTable容器使用synchronized来保证线程安全，但在线程竞争激烈的情况下HashTable的效率非常低下。因为当一个线程访问HashTable的同步方法，其他线程也访问HashTable的同步方法，会进入阻塞或轮询状态。如线程1使用put进行元素添加，线程2不但不能使用put方法添加元素，也不能使用get方法来获取元素，所以竞争越激烈效率越低。&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;ConcurrentHashMap的锁分段技术可有效提升并发访问率&lt;/p&gt;

        &lt;p&gt;HashTable容器在竞争激烈的并发环境下表现出效率低下的原因是所有访问HashTable的线程都必须竞争同一把锁，假如容器里又多把锁，每一把锁用于锁容器其中一部分数据，那么当多线程访问容器里不同数据段的数据时，线程间就不会存在锁竞争，从而可以有效提高并发访问率，这就是ConcurrentHashMap所使用的锁分段技术。首先将数据分成一段一段地存储，然后给每一段数据配一把锁，当一个线程占用锁访问其中一个段数据的时候，其他段的数据也能被其他线程访问。&lt;/p&gt;
      &lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;ConcurrentHashMap的结构&lt;/strong&gt;&lt;/p&gt;

    &lt;p&gt;通过ConcurrentHashMap的类图来分析ConcurrentHashMap的结构。
&lt;img src=&quot;../assets/img/java-concurrency-collectionandfram-1.png&quot; alt=&quot;java-concurrency-collectionandfram-1&quot; /&gt;
ConcurrentHashMap是由Segment数组结构组成。Segment是一种可重入锁（ReentrantLock），在ConcurrentHashMap里扮演锁的角色；HashEntry则用于存储健值对数据。一个ConcurrentHashMap里包含一个Segment数组。Segment结构和HashMap类似，是一种数组和链表的结构。一个Segment里包含一个HashEntry数组，每个HashEntry是一个链表结构的元素，每个segment守护着一个HashEntry数组里的元素，当对HashEntry数组的数据进行修改时，必须首先获得与它对应的Segment锁。
&lt;img src=&quot;../assets/img/java-concurrency-collectionandfram-2.png&quot; alt=&quot;java-concurrency-collectionandfram-2&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;concurrentlinkedqueue&quot;&gt;ConcurrentLinkedQueue&lt;/h2&gt;

&lt;p&gt;在并发编程中，有时候需要使用线程安全的队列。如果要实现一个线程安全的队列有两种方式：一种是使用阻塞算法，另一种是使用非阻塞算法。使用阻塞算法的队列可以用一个锁（入队和出队用同一把锁）或两个锁（入队和出队不同的锁）等方式来实现。非阻塞的实现方式则可以使用循环CAS的方式来实现。&lt;/p&gt;

&lt;p&gt;ConcurrentLinkedQueue是一个基于链接节点的无界线程安全队列，它采用先进先出的规则对节点进行排序，当我们添加一个元素的时候，它会添加到队列的尾部；当我们获取一个元素时，他会返回队列头部的元素。它采用”wait-free”算法（即CAS算法）来实现。&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;ConcurrentLinkedQueue的结构&lt;/strong&gt;&lt;/p&gt;

    &lt;p&gt;ConcurrentLinkedQueue类图如下：
&lt;img src=&quot;../assets/img/java-concurrency-collectionandfram-3.png&quot; alt=&quot;java-concurrency-collectionandfram-3&quot; /&gt;
ConcurrentLinkedQueue由head节点和tail节点组成，每个节点（Node）由节点元素（item）和指向下一个节点（next）的引用组成，节点与节点之间就是通过这个next关联起来，从而组成一张链表结构的队列。默认情况下head节点存储的元素为空，tail节点等于head节点。&lt;/p&gt;

    &lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;transient&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;volatile&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Node&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;E&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;tail&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;head&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;入队列&lt;/strong&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;出队列&lt;/strong&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;java中的阻塞队列&quot;&gt;Java中的阻塞队列&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;什么是阻塞队列&lt;/strong&gt;&lt;/p&gt;

    &lt;p&gt;阻塞队列（BlockingQueue）是一个支持两个附加操作的队列。这两个附加的操作支持阻塞的插入和移除方法。&lt;/p&gt;

    &lt;ol&gt;
      &lt;li&gt;支持阻塞的插入方法：意思是当队列满时，队列会阻塞插入元素的线程，直到队列不满。&lt;/li&gt;
      &lt;li&gt;支持阻塞的移除方法：意思是在队列为空时，获取元素的线程会等待队列变为非空。&lt;/li&gt;
    &lt;/ol&gt;

    &lt;p&gt;阻塞队列常用于生产者和消费者的场景，生产者是向队列里添加元素的线程，消费者时从队列里去元素的线程。阻塞队列就是生产者用来存放元素、消费者用来获取元素的容器。&lt;/p&gt;

    &lt;p&gt;在阻塞队列不可用时，两个附加操作提供了4中处理方式。&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;抛出异常：当队列满时，如果再往队列里插入元素，会抛出&lt;code class=&quot;highlighter-rouge&quot;&gt;IllegalStateException(&quot;Queue full&quot;)&lt;/code&gt;异常。当队列空时，从队列里取元素会抛出&lt;code class=&quot;highlighter-rouge&quot;&gt;NoSuchElementException&lt;/code&gt;异常。&lt;/li&gt;
      &lt;li&gt;返回特殊值：当往队列插入元素时，会返回元素是否插入成功，成功返回true。如果是移除方法，则是从队列里取出一个元素，如果没有则返回null。&lt;/li&gt;
      &lt;li&gt;一直阻塞：当阻塞队列满时，如果生产者线程往队列里put元素，队列会一直阻塞生产者线程，直到队列可用或者响应中断退出。当队列空时，如果消费者线程从队列里take元素，队列会阻塞住消费者线程，直到队列不为空。&lt;/li&gt;
      &lt;li&gt;超时退出：当阻塞队列满时，如果生产者线程往队列里插入元素，队列会阻塞生产者线程一段时间，如果超过了指定的时间，生产者线程就会退出。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;方法/处理方式&lt;/th&gt;
      &lt;th&gt;抛出异常&lt;/th&gt;
      &lt;th&gt;返回特殊值&lt;/th&gt;
      &lt;th&gt;一直阻塞&lt;/th&gt;
      &lt;th&gt;超时退出&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;插入方法&lt;/td&gt;
      &lt;td&gt;add(e)&lt;/td&gt;
      &lt;td&gt;offer(e)&lt;/td&gt;
      &lt;td&gt;put(e)&lt;/td&gt;
      &lt;td&gt;offer(e,time,unit)&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;移除方法&lt;/td&gt;
      &lt;td&gt;remove()&lt;/td&gt;
      &lt;td&gt;poll()&lt;/td&gt;
      &lt;td&gt;take()&lt;/td&gt;
      &lt;td&gt;poll(time, unit)&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;检查方法&lt;/td&gt;
      &lt;td&gt;element()&lt;/td&gt;
      &lt;td&gt;peek()&lt;/td&gt;
      &lt;td&gt;不可用&lt;/td&gt;
      &lt;td&gt;不可用&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;Java里的阻塞队列&lt;/strong&gt;&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;ArrayBlockingQueue：一个由数组结构组成的有界阻塞队列。&lt;/li&gt;
      &lt;li&gt;LinkedBlockingQueue：一个由链表结构组成的有界阻塞队列。&lt;/li&gt;
      &lt;li&gt;PriorityBlockingQueue：一个支持优先级排序的无界阻塞队列。&lt;/li&gt;
      &lt;li&gt;DelayQueue：一个使用优先级队列实现的无阻塞队列。&lt;/li&gt;
      &lt;li&gt;SynchronousQueue：一个不存储元素的阻塞队列。&lt;/li&gt;
      &lt;li&gt;LinkedTransferQueue：一个由链表结构组成的无界阻塞队列。&lt;/li&gt;
      &lt;li&gt;LinkedBlockingDeque：一个由链表结构组成的双向阻塞队列。&lt;/li&gt;
    &lt;/ul&gt;

    &lt;ol&gt;
      &lt;li&gt;
        &lt;p&gt;&lt;strong&gt;ArrayBlockingQueue&lt;/strong&gt;&lt;/p&gt;

        &lt;p&gt;ArrayBlockingQueue是一个用数组实现的有界阻塞队列。此队列按照先进先出（FIFO）的原则对元素进行排序。&lt;/p&gt;

        &lt;p&gt;默认情况下不保证线程公平的访问队列，所谓公平访问队列是指阻塞的线程，可以按照阻塞的先后顺序访问队列，即先阻塞线程先访问队列。非公平性是先等待的线程是非公平的，当队列可用时，阻塞的线程都可以争夺访问队列的资格，有可能先阻塞的线程最后才访问队列。为了保证公平性，通常会降低吞吐量。访问者的公平性时使用可重入锁实现的。&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;&lt;strong&gt;LinkedBlockingQueue&lt;/strong&gt;&lt;/p&gt;

        &lt;p&gt;LinkedBlockingQueue是一个用链表实现的有界阻塞队列。此队列的默认和最大长度为Integer.MAX_VALUE。此队列按照先进先出的原则对元素进行排序。&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;&lt;strong&gt;PriorityBlockingQueue&lt;/strong&gt;&lt;/p&gt;

        &lt;p&gt;PriorityBlockingQueue是一个支持优先级的无界阻塞队列。默认情况下元素采取自然顺序生序排列，也可以自定义实现compareTo()方法来指定元素的排序规则，或者初始化PriorityBlockingQueue时，指定构造参数Comparator来对元素进行排序。需要注意的是不能保证同优先级元素的顺序。&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;&lt;strong&gt;DelayQueue&lt;/strong&gt;&lt;/p&gt;

        &lt;p&gt;DelayQueue是一个支持延时获取元素的无界阻塞队列。队列使用PriorityQueue来实现。队列中的元素必须实现Delayed接口，在创建元素时可以指定多久才能从队列中获取当前元素。只有在延迟期满时才能从队列中提取元素。&lt;/p&gt;

        &lt;p&gt;DelayQueue非常有用，可以将DelayQueue运用在以下应用场景。&lt;/p&gt;

        &lt;ul&gt;
          &lt;li&gt;缓存系统的设计：可以用DelayQueue保存缓存元素的有效期，使用一个线程循环查询DelayQueue，一旦能从DelayQueue中获取元素时，表示缓存有效期到了。&lt;/li&gt;
          &lt;li&gt;定时任务调度：使用DelayQueue保存当天将会执行的任务和执行时间，一旦从DelayQueue中获取到任务就开始执行，比如TimerQueue就是使用DelayQueue实现的。&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;&lt;strong&gt;SynchronousQueue&lt;/strong&gt;&lt;/p&gt;

        &lt;p&gt;SynchronousQueue是一个不存储元素的阻塞队列。每一个put操作必须等待一个take操作，否则不能继续添加元素。&lt;/p&gt;

        &lt;p&gt;它支持公平访问队列。默认情况下线程采用非公平性策略访问队列。使用以下构造方法可以创建公平性访问的SynchronousQueue，如果设置为true，则等待线程会采用先进先出的顺序访问队列。&lt;/p&gt;

        &lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;SynchronousQueue&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;boolean&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;fair&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;){&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;transfere&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;fair&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;?&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;TransferQueue&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;TransferStack&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;        &lt;/div&gt;

        &lt;p&gt;SynchronousQueue可以看成是一个传球手，负责把生产者线程处理的数据直接传递给消费者线程。队列本身不存储任何元素，非常适合传递性场景。SynchronousQueue的吞吐量高于LinkedBlockingQueue和ArrayBlockingQueue。&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;&lt;strong&gt;LinkedTransferQueue&lt;/strong&gt;&lt;/p&gt;

        &lt;p&gt;LinkedTransferQueue是一个由链表结构组成的无界阻塞TransferQueue队列。相对于其他阻塞队列，LinkedTransferQueue多了tryTransfer和transfer方法。&lt;/p&gt;

        &lt;ul&gt;
          &lt;li&gt;
            &lt;p&gt;transfer方法&lt;/p&gt;

            &lt;p&gt;如果当前有消费者正在等待接收元素（消费者使用take()方法或带时间限制的poll()方法时），transfer方法可以把生产者传入的元素立刻transfer（传输）给消费者。如果没有消费者等待接收元素，transfer方法会将元素存放在队列的tail节点，并等到该元素被消费者消费了才返回。&lt;/p&gt;
          &lt;/li&gt;
          &lt;li&gt;
            &lt;p&gt;tryTransfer方法&lt;/p&gt;

            &lt;p&gt;tryTransfer方法是用来试探生产者传入的元素是否能直接传递给消费者。如果没有消费者等待接收元素，则返回false。和transfer方法的区别是tryTransfer方法无论消费者是否接收，方法立即返回，而transfer方法是必须等到消费者消费了才返回。&lt;/p&gt;

            &lt;p&gt;对于带有时间限制的tryTransfer(E e, long timeout, TimeUnit unit)方法，试图把生产者传入的元素直接给消费者，但是如果没有消费者消费该元素则等待指定的时间再返回，如果超时还没消费元素，则返回false，如果在超时时间内消费了元素，则返回true。&lt;/p&gt;
          &lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;&lt;strong&gt;LinkedBlockingDeque&lt;/strong&gt;&lt;/p&gt;

        &lt;p&gt;LinkedBlockingDeque是一个由链表结构组成的双向阻塞队列。所谓双向队列指的是可以从队列的两端插入和移出元素。双向队列因为多了一个操作队列的入口，在多线程同时入队时，也就减少了一半的竞争。相比其他阻塞队列，LinkedBlockingDeque多了addFirst、addLast、offerFirst、offerLast、peekFirst和peekLast等方法。以First结尾的方法，表示插入、获取（peek）或移除双端队列的第一个元素。以Last单词结尾的方法，表示插入、获取或移除双端队列的最后一个元素。另外，插入方法add等同于addList，移除方法remove等效于removeFirst。但是take方法却等同于takeFirst。在初始化LinkedBlockingDeque时可以设置容量防止其过度膨胀。另外，双向阻塞队列可以运用在”工作窃取”模式中。&lt;/p&gt;
      &lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;阻塞队列的实现原理&lt;/strong&gt;&lt;/p&gt;

    &lt;p&gt;使用通知模式实现。所谓通知模式，就是当生产者往满的队列里添加元素时会阻塞住生产者，当消费者消费了一个队列中的元素后，会通知生产者当前队列可用。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;forkjoin框架&quot;&gt;Fork/Join框架&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;什么是Fork/Join框架&lt;/strong&gt;&lt;/p&gt;

    &lt;p&gt;Fork/Join框架是Java7提供的一个用于并行执行任务的框架，是一个把大任务分割成若干个小任务，在最终汇总每个小任务结构后得到大任务结果的框架。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;工作窃取算法&lt;/strong&gt;&lt;/p&gt;

    &lt;p&gt;工作窃取（work-stealing）算法是指某个线程从其他队列里窃取任务来执行。那么，为什么需要使用工作窃取算法呢？假如我们需要做一个比较大的任务，可以把这个任务分割为若干互不依赖的子任务，为了减少线程间的竞争，把这些子任务分别放在不同的队列里，并为每个队列创建一个单独的线来执行队列里的任务，线程和队列一一对应。比如A线程负责处理A队列里的任务。但是，有的线程会先把自己队列里的任务干完，而其他线程对应的队列里还有任务等待处理。干完活儿的线程与其等着，不如去帮其他线程干活，于是它就去其他线程的队列里窃取一个任务来执行。而在这时它们会访问同一个队列，所以为了减少窃取任务线程和被窃取任务线程之间的竞争，通常会使用双端队列，被窃取任务线程永远从双端队列的头部拿任务执行，而窃取任务的线程永远从双端队列的尾部拿任务执行。&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;工作窃取算法的优点：充分利用线程进行并行计算，减少了线程间的竞争。&lt;/li&gt;
      &lt;li&gt;工作窃取算法的缺点：在某些情况下还是存在竞争，比如双端队列里只有一个任务时。并且算法会消耗了更多的系统资源，比如创建多个线程和多个双端队列。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;Fork/Join框架的设计&lt;/strong&gt;&lt;/p&gt;

    &lt;ol&gt;
      &lt;li&gt;
        &lt;p&gt;步骤1：分割任务。首先我们需要一个fork类把大任务分割成子任务，有可能任务还是很大，所以还需要不停地分割，直到分割出的子任务足够小。&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;步骤2：执行任务并合并结果。分割的子任务分别放在双端队列里，然后几个启动线程分别从双端队列里获取任务执行。子任务执行完的结果都统一放在一个队列里，启动一个线程从队列里拿数据，然后合并这些数据。&lt;/p&gt;

        &lt;p&gt;Fork/Join使用两个类来完成以上两件事情。&lt;/p&gt;

        &lt;ol&gt;
          &lt;li&gt;
            &lt;p&gt;Fork/JoinTask：我们使用ForkJoin框架，必须首先创建一个ForkJoin任务。它提供在任务中执行fork()和join()操作的机制。通常情况下，我们不需要直接继承ForkJoinTask类，只需要继承它的子类，Fork/Join框架提供了以下两个子类。&lt;/p&gt;

            &lt;ul&gt;
              &lt;li&gt;RecursiveAction：用于没有返回结果的任务。&lt;/li&gt;
              &lt;li&gt;RecursiveTask：用于有返回结果的任务。&lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
          &lt;li&gt;
            &lt;p&gt;ForkJoinPool：ForkJoinTask需要通过ForkJoinPool来执行。&lt;/p&gt;

            &lt;p&gt;任务分割出的子任务会添加到当前工作线程所维护的双端队列中，进入队列的头部。当一个工作线程的队列里暂时没有任务时，他会随机从其他工作线程的队列的尾部获取一个任务。&lt;/p&gt;
          &lt;/li&gt;
        &lt;/ol&gt;
      &lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
&lt;/ol&gt;</content><author><name>郝强</name></author><category term="resources" /><category term="concurrency" /><summary type="html">ConcurrentHashMap的实现原理与使用</summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="http://localhost:4000/java-concurrency-collectionandfram-0.jpeg" /></entry><entry><title type="html">Java中的锁</title><link href="http://localhost:4000/resources/java-concurrency-lock.html" rel="alternate" type="text/html" title="Java中的锁" /><published>2018-03-11T00:00:00+08:00</published><updated>2018-03-11T00:00:00+08:00</updated><id>http://localhost:4000/resources/java-concurrency-lock</id><content type="html" xml:base="http://localhost:4000/resources/java-concurrency-lock.html">&lt;h2 id=&quot;lock接口&quot;&gt;Lock接口&lt;/h2&gt;

&lt;p&gt;锁是用来控制多个线程访问共享资源的方式，一般来说，一个锁能够防止多个线程同时访问共享资源（但是有些锁是可以允许多个线程并发的访问共享资源，比如读写锁）。在Lock接口出现之前，Java程序是靠synchronized关键字实现锁功能的，而Java SE 5之后，并发包中新增了Lock接口（以及相关实现类）用来实现锁功能，它提供了与synchronized关键字类似的同步功能，只是在使用时需要显式地获取和释放锁。&lt;/p&gt;

&lt;p&gt;Lock接口提供的synchronized关键字不具备的主要特性&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;特性&lt;/th&gt;
      &lt;th&gt;描述&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;尝试非阻塞的获取锁&lt;/td&gt;
      &lt;td&gt;当前线程会尝试获取锁，如果这一时刻锁没有被其他线程获取到，则成功获取并持有锁&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;能被中断地获取锁&lt;/td&gt;
      &lt;td&gt;与synchronized不同，获取到锁的线程能够响应中断，当获取到锁的线程被中断时，中断异常将会被抛出，同时锁会被释放&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;超时获取锁&lt;/td&gt;
      &lt;td&gt;在指定的截止时间之前获取锁，如果截止时间到了仍旧无法获取锁，则返回&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;Lock是一个接口，它定义了锁获取和释放的基本操作&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;方法名称&lt;/th&gt;
      &lt;th&gt;描述&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;void lock()&lt;/td&gt;
      &lt;td&gt;获取锁，调用该方法当前的线程将会获取锁，当锁获取后，从该方法返回&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;void lockInterruptibly() throws InterruptedException&lt;/td&gt;
      &lt;td&gt;可中断地获取锁，和lock()方法的不同之处在于该方法会响应中断，即在锁的获取中可以中断当前线程&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;boolean tryLock()&lt;/td&gt;
      &lt;td&gt;尝试非阻塞地获取锁，调用该方法后立刻返回，如果能够返回则返回true，否则返回false&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;boolean tryLock(long time, TimeUnit unit) throws InterrupedException&lt;/td&gt;
      &lt;td&gt;超时的获取锁，当前线程在一下3种情况下会返回：1.当前线程在超时时间内获取了锁；2.当前线程在超时时间内被中断；3.超时时间结束，返回false&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;void unlock()&lt;/td&gt;
      &lt;td&gt;释放锁&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Condition newCondition()&lt;/td&gt;
      &lt;td&gt;获取等待通知组件，该组件和当前的锁绑定，当前线程只有获得了锁，才能调用该组件的wait()方法，而调用后，当前线程将释放锁&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h2 id=&quot;队列同步器&quot;&gt;队列同步器&lt;/h2&gt;

&lt;p&gt;队列同步器AbstractQueuedSynchronizer（以下简称同步器），是用来构建锁或者其他同步组件的基础框架，它使用了一个int成员变量表示同步状态，通过内置的FIFO队列来完成资源获取线程的排队工作。&lt;/p&gt;

&lt;h2 id=&quot;重入锁&quot;&gt;重入锁&lt;/h2&gt;

&lt;p&gt;重入锁ReentrantLock，顾名思义，就是支持重新进入的锁，他表示该锁能够支持一个线程对资源的重复加锁。除此之外，该锁还支持获取锁时的公平和非公平性选择。&lt;/p&gt;

&lt;p&gt;ReentrantLock虽然没能像synchronized关键字一样支持隐式的重进入，但是在调用lock()方法时，已经获取到的锁的线程，能够再次调用lock()方法获取锁而不被阻塞。&lt;/p&gt;

&lt;p&gt;ReentrantLock提供了一个构造函数，能够控制锁是否公平。&lt;/p&gt;

&lt;h2 id=&quot;读写锁&quot;&gt;读写锁&lt;/h2&gt;

&lt;p&gt;之前提到的锁基本都是排它锁，这些锁在同一时刻只允许一个线程进行访问，而读写锁在同一时刻可以允许多个读线程访问，但是在写线程访问的同时，所有的读线程和其他写线程均被阻塞。读写锁维护了一对锁，一个读锁和一个写锁，通过分离读锁和写锁，使得并发性比一般的排它锁有了很大的提升。&lt;/p&gt;

&lt;p&gt;ReentranReadWriteLock的特性&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;特性&lt;/th&gt;
      &lt;th&gt;说明&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;公平性选择&lt;/td&gt;
      &lt;td&gt;支持非公平（默认）和公平的锁获取方式，吞吐量还是非公平优于公平&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;重进入&lt;/td&gt;
      &lt;td&gt;该锁支持重进入，以读写线程为例：读线程在获取了读锁之后，能够再次获取读锁。而写线程在获取了写锁之后能够再次获取写锁，同时也可以获取读锁&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;锁降级&lt;/td&gt;
      &lt;td&gt;遵循获取写锁，获取读锁在释放写锁的次序，写锁能够降级成为读锁&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h2 id=&quot;condition接口&quot;&gt;Condition接口&lt;/h2&gt;

&lt;p&gt;任意一个Java对象，都有一组监视器方法，主要包括wait()、wait(long timeout)、notify()以及notifyAll()方法，这些方法与synchronized同步关键字配合，可以实现等待/通知模式。Condition接口也提供了类似Object的监视器方法，与Lock配合可以实现等待/通知模式，但是这两者在使用方式以及功能特性上还是有差别的。&lt;/p&gt;</content><author><name>郝强</name></author><category term="resources" /><category term="concurrency" /><summary type="html">Lock接口</summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="http://localhost:4000/java-concurrency-lock-0.jpeg" /></entry><entry><title type="html">Java并发编程基础</title><link href="http://localhost:4000/resources/java-concurrency-basic.html" rel="alternate" type="text/html" title="Java并发编程基础" /><published>2018-03-10T00:00:00+08:00</published><updated>2018-03-10T00:00:00+08:00</updated><id>http://localhost:4000/resources/java-concurrency-basic</id><content type="html" xml:base="http://localhost:4000/resources/java-concurrency-basic.html">&lt;h2 id=&quot;java内存模型的基础&quot;&gt;Java内存模型的基础&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;【&lt;strong&gt;Java内存模型的抽象结构&lt;/strong&gt;】：&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;../assets/img/java-concurrency-space-1.png&quot; alt=&quot;java-concurrency-space-1&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;【&lt;strong&gt;从源代码到指令序列的重排序&lt;/strong&gt;】：在执行程序时，为了提高性能，编译器和处理器常常会对指令做重排序。重排序分为三种类型：&lt;/p&gt;

    &lt;ol&gt;
      &lt;li&gt;编译器优化的重排序。编译器在不改变单线程程序语义的前提下，可以重新安排语句的执行顺序。&lt;/li&gt;
      &lt;li&gt;指令集并行的重排序。现代冲利器采用了指令级并行技术来将多条指令重叠执行。如果不存在数据依赖性，处理器可以改变语句对应机器指令的执行顺序。&lt;/li&gt;
      &lt;li&gt;内存系统的重排序。由于处理器使用缓存和读/写缓冲区，这使得加载和存储操作看上去可能是乱序执行&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;重排序&quot;&gt;重排序&lt;/h2&gt;

&lt;p&gt;重排序是指编译器和处理器为了优化程序性能而对指令序列进行重新排序的一种手段。&lt;/p&gt;

&lt;h2 id=&quot;顺序一致性&quot;&gt;顺序一致性&lt;/h2&gt;

&lt;p&gt;顺序一致性内存模型是一个理论参考模型，在设计的时候，处理器的内存模型和编程语言的内存模型都会以顺序一致性内存模型作为参考。&lt;/p&gt;

&lt;h2 id=&quot;volatile的内存语义&quot;&gt;volatile的内存语义&lt;/h2&gt;

&lt;h2 id=&quot;锁的内存语义&quot;&gt;锁的内存语义&lt;/h2&gt;

&lt;h2 id=&quot;final域的内存语义&quot;&gt;final域的内存语义&lt;/h2&gt;

&lt;h2 id=&quot;happens-before&quot;&gt;happens-before&lt;/h2&gt;

&lt;h2 id=&quot;双重检查锁与延迟初始化&quot;&gt;双重检查锁与延迟初始化&lt;/h2&gt;

&lt;h2 id=&quot;java内存模型综述&quot;&gt;Java内存模型综述&lt;/h2&gt;</content><author><name>郝强</name></author><category term="resources" /><category term="concurrency" /><summary type="html">Java内存模型的基础</summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="http://localhost:4000/java-concurrency-basic-0.jpeg" /></entry><entry><title type="html">Java内存模型</title><link href="http://localhost:4000/resources/java-concurrency-space.html" rel="alternate" type="text/html" title="Java内存模型" /><published>2018-03-09T00:00:00+08:00</published><updated>2018-03-09T00:00:00+08:00</updated><id>http://localhost:4000/resources/java-concurrency-space</id><content type="html" xml:base="http://localhost:4000/resources/java-concurrency-space.html">&lt;h2 id=&quot;java内存模型的基础&quot;&gt;Java内存模型的基础&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;【&lt;strong&gt;Java内存模型的抽象结构&lt;/strong&gt;】：&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;../assets/img/java-concurrency-space-1.png&quot; alt=&quot;java-concurrency-space-1&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;【&lt;strong&gt;从源代码到指令序列的重排序&lt;/strong&gt;】：在执行程序时，为了提高性能，编译器和处理器常常会对指令做重排序。重排序分为三种类型：&lt;/p&gt;

    &lt;ol&gt;
      &lt;li&gt;编译器优化的重排序。编译器在不改变单线程程序语义的前提下，可以重新安排语句的执行顺序。&lt;/li&gt;
      &lt;li&gt;指令集并行的重排序。现代冲利器采用了指令级并行技术来将多条指令重叠执行。如果不存在数据依赖性，处理器可以改变语句对应机器指令的执行顺序。&lt;/li&gt;
      &lt;li&gt;内存系统的重排序。由于处理器使用缓存和读/写缓冲区，这使得加载和存储操作看上去可能是乱序执行&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;重排序&quot;&gt;重排序&lt;/h2&gt;

&lt;p&gt;重排序是指编译器和处理器为了优化程序性能而对指令序列进行重新排序的一种手段。&lt;/p&gt;

&lt;h2 id=&quot;顺序一致性&quot;&gt;顺序一致性&lt;/h2&gt;

&lt;p&gt;顺序一致性内存模型是一个理论参考模型，在设计的时候，处理器的内存模型和编程语言的内存模型都会以顺序一致性内存模型作为参考。&lt;/p&gt;

&lt;h2 id=&quot;volatile的内存语义&quot;&gt;volatile的内存语义&lt;/h2&gt;

&lt;h2 id=&quot;锁的内存语义&quot;&gt;锁的内存语义&lt;/h2&gt;

&lt;h2 id=&quot;final域的内存语义&quot;&gt;final域的内存语义&lt;/h2&gt;

&lt;h2 id=&quot;happens-before&quot;&gt;happens-before&lt;/h2&gt;

&lt;h2 id=&quot;双重检查锁与延迟初始化&quot;&gt;双重检查锁与延迟初始化&lt;/h2&gt;

&lt;h2 id=&quot;java内存模型综述&quot;&gt;Java内存模型综述&lt;/h2&gt;</content><author><name>郝强</name></author><category term="resources" /><category term="concurrency" /><summary type="html">Java内存模型的基础</summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="http://localhost:4000/java-concurrency-space-0.jpeg" /></entry><entry><title type="html">Spring事务</title><link href="http://localhost:4000/resources/spring-transaction.html" rel="alternate" type="text/html" title="Spring事务" /><published>2018-03-08T00:00:00+08:00</published><updated>2018-03-08T00:00:00+08:00</updated><id>http://localhost:4000/resources/spring-transaction</id><content type="html" xml:base="http://localhost:4000/resources/spring-transaction.html">&lt;h2 id=&quot;事务传播行为&quot;&gt;事务传播行为&lt;/h2&gt;

&lt;p&gt;传播行为级别，定义的是事务的控制范围。通俗点说，执行到某段代码时，对已存在的事务的不同处理方式。&lt;/p&gt;

&lt;p&gt;Spring对JDBC的事务隔离级别进行了补充和扩展，并提出了种事务传播行为。&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;PROPAGATION_REQUIRED&lt;/strong&gt;：需要事务处理。有则使用，无则新建。这是Spring默认的事务传播行为。该级别的特征是，如果Context中已经存在事务，那么就将当前需要使用事务的代码加入到Context的事务中去执行，如果当前Context中不存在事务，则新建一个事物执行代码。这个级别通常能满足大多数的业务场景。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;PROPAGATION_SUPPORTS&lt;/strong&gt;：支持事务处理。该级别的特性是，如果Context存在事务，则将代码加入到Context的事务中执行，如果Context中没有事务，则使用非事务的方式执行。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;PROPAGATION_MANDATORY&lt;/strong&gt;：强制要求事务。该级别的特性是，当要以事务的方式执行代码时，要求Context中必须已经存在事务，否则就会抛出异常！使用MANDATORY强制事务，可以有效地控制“必须以事务执行的代码，却忘记给它加上事务控制”这种情况发生。举个简单的例子：有一个方法，对这个方法的要求时一旦被调用，该方法就必须包含在事务中才能正常执行，那么这个方法就适合设置为PROPAGATION_MANDATORY强制事务传播行为，从而在代码层面加以控制。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;PROPAGATION_REQUIRES_NEW&lt;/strong&gt;：每次都新建一个事务。该级别的特点是，当执行到一段需要事务的代码时，先判断Context中是否已经有事务存在，如果不存在，就去新建一个事物；如果已经存在，就suspend挂起当前事务，然后创建一个新事务去执行，直到新事务执行完毕，才会恢复先前挂起的Context事务。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;PROPAGATION_NOT_SUPPORTED&lt;/strong&gt;：不支持事务。该级别的特点是，如果发现当Context中有事务存在，则挂起该事务，然后执行逻辑代码，执行完毕后，恢复先前挂起的Context事务。这个传播行为的事务，可以缩小事务处理过程的范围。举个简单的例子，在一个事物中要调用一段非核心业务的逻辑操作1000次，如果这段逻辑放在事务中，会导致该事务的范围变大，生命周期变长，为了避免因事物范围扩大、周期变长而引发一些的实现没有考虑到的异常情况发生，可以将这段逻辑设置为NOT_SUPPORTED不支持事务传播行为。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;PROPAGATION_NEVER&lt;/strong&gt;：对事务要求更严格。不能出现事务！该级别的特点是，设置了该级别的代码，在执行前一旦发现Context中有事务存在，就会抛出Runtime异常，强制停止执行，有我无他！&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;PROPATGATION_NESTED&lt;/strong&gt;：嵌套事务。该级别的特点是，如果Context中存在的事务A，就将当前代码对应的事务B加入到事务A内部，嵌套执行；如果Context中不存在事务，则新建事务执行代码。换句话说。事务A与事务B之间是父子关系，A是父，B是子。理解嵌套事务的关键点是：save point。&lt;/p&gt;

    &lt;p&gt;父、子事务嵌套、save point的说明：&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;父事务会在子事务进入之前创建一个save point；&lt;/li&gt;
      &lt;li&gt;子事务rollback，父事务只会会滚到save point，而不会回滚整个父事务；&lt;/li&gt;
      &lt;li&gt;父事务commit之前，必须先commit子事务。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;</content><author><name>郝强</name></author><category term="resources" /><category term="spring" /><summary type="html">事务传播行为</summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="http://localhost:4000/spring-transaction-0.jpeg" /></entry><entry><title type="html">数据库事务</title><link href="http://localhost:4000/resources/db-transaction.html" rel="alternate" type="text/html" title="数据库事务" /><published>2018-03-07T00:00:00+08:00</published><updated>2018-03-07T00:00:00+08:00</updated><id>http://localhost:4000/resources/db-transaction</id><content type="html" xml:base="http://localhost:4000/resources/db-transaction.html">&lt;h2 id=&quot;数据库四大特性&quot;&gt;数据库四大特性&lt;/h2&gt;

&lt;p&gt;数据库的四大特性简称ACID：Atomicity（原子性）、Consistency（一致性）、Isolation（隔离性）和Durability（持久性）。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;【原子性（Atomicity）】：原子性是指事物包含的操作要么全部成功，要么全部失败回滚。也就是说事务的操作如果成功就必须完全应用到数据库，如果操作失败则不能对数据库有任何影响。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;【一致性（Consistency）】：一致性是指事物必须使数据库从一个一致性状态变换到另一个一致性状态，也就是说一个事物执行之前和执行之后都必须处于一执行状态。&lt;/p&gt;

    &lt;p&gt;比如说转账，假设用户A和用户B两者的钱加起来一共是50000，那么不管A和B之间如何转账，转账几次，事物结束后两个用户的钱相加起来应该还是50000，这就是事物一致性。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;【隔离性（Isolation）】：隔离性是当多个用户并发访问数据库时，比如操作同一张表时，数据库为每一个用户开启的事物，不能被其他事物的操作所干扰，多个并发事物之间要互相隔离。&lt;/p&gt;

    &lt;p&gt;也就是说，对于任意两个并发事务T1和T2，在事务T1看来，T2要么在T1开始之前就已经结束，要么在T1结束之后才开始，这样每个事物都感觉不到其他事务的并发执行。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;【持久性（Durability）】：持久性是指一个事物一旦被提交了，那么对数据库中的改变就是永久性的，即便是在数据库系统遇到故障的情况下也不会丢失提交事务的操作。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;数据库四种事务隔离级别&quot;&gt;数据库四种事务隔离级别&lt;/h2&gt;

&lt;p&gt;SQL标准定义了4类隔离级别，包括了一些具体规则，采用限定事务内外的哪些改变是可见的，哪些是不可见的。低级别的隔离级一般支持高并发处理，并拥有更低的系统开销。&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;【&lt;strong&gt;Read Uncommitted（读取未提交内容）&lt;/strong&gt;】：在该隔离级别中，所有事务可以看到其他未提交事务的执行结果。本级别隔离很少用于实际应用，比其他隔离级别性能也好不了多少。&lt;em&gt;读取未提交的数据称为“脏读（Dirty Read）”&lt;/em&gt;。&lt;/li&gt;
  &lt;li&gt;【&lt;strong&gt;Read Committed（读取提交内容）&lt;/strong&gt;】：这是大多数数据库默认的隔离级别，但是，不是MySQL的默认隔离级别。他满足了隔离简单的定义：一个事务只能看到已提交事务所做的改变。这种隔离会出现“不可重复读”的现象（Non-repeatable Read），因为同一事务的其他实例在该实例处理期间可能会有新的commit（包括update和delete），导致目标数据被修改，所以同一select可能返回不同结果。&lt;/li&gt;
  &lt;li&gt;【&lt;strong&gt;Repeatable Read（可重读）&lt;/strong&gt;】：这是MySQL默认的隔离级别，它确保同一事务的多个实例在并发读取数据时，会看到同样的数据行（目标数据行不会被修改）。不过，会出现“幻读”的现象。幻读是由insert引起的，简单来说，幻读指当用户读取某一范围的数据行时，另一个事务又在该范围内插入了新行，当用户再读取该范围的数据行时，会发现有新的“幻影”行。innoDB和Falcon存储引擎通过多版本并发控制（MVCC，Multiversion Concurrency Control）机制解决了该问题。&lt;/li&gt;
  &lt;li&gt;【&lt;strong&gt;Serializable（可串行化&lt;/strong&gt;】：这是最高的事务隔离级别，它通过强制事务排序，使之不可能相互冲突，从而解决幻读问题。简而言之，他是每个读的数据行上，加了共享锁，在这个级别，可能导致大量的超时现象和锁竞争。&lt;/li&gt;
&lt;/ol&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;&lt;em&gt;脏读（Dirty Read）&lt;/em&gt;&lt;/strong&gt;：某个事务已经更新一份数据，另一个事务在此时读取了同一份数据，由于某些原因，前一个事务RollBack了操作，则后一个事物所读取的数据就会是不正确的。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;&lt;em&gt;不可重复读（Non-repeatable Read）&lt;/em&gt;&lt;/strong&gt;：在一个事务内，多次读取同一数据。在这个事务还没有结束时，另外一个事务也访问该同一数据。那么，在第一个事务中的两次读数据之间，由于第二个事务的修改，那么第一个事务两次读到的数可能是不一样的。这样就发生了在一个事务内两次读到的数据不一样的，因此称为时不可重复读。（update和delete引起）&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;&lt;em&gt;幻读（Phantom Read）&lt;/em&gt;&lt;/strong&gt;：在一个事务的两次查询中数据笔数不一致，例如有一个事物查询了几列（Row）数据，而另一个事务却在时插入了新的几列数据，西芹钱的事务在接下来的查询中，就会发现有几列数据是它先前所没有的。（由insert引起）&lt;/li&gt;
&lt;/ul&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;隔离级别&lt;/th&gt;
      &lt;th&gt;脏读&lt;/th&gt;
      &lt;th&gt;不可重复读&lt;/th&gt;
      &lt;th&gt;幻读&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;读未提交（Read Uncommitted）&lt;/td&gt;
      &lt;td&gt;✔&lt;/td&gt;
      &lt;td&gt;✔&lt;/td&gt;
      &lt;td&gt;✔&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;读已提交（Read committed）&lt;/td&gt;
      &lt;td&gt;✖&lt;/td&gt;
      &lt;td&gt;✔&lt;/td&gt;
      &lt;td&gt;✔&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;可重复读（Repeatable Read）&lt;/td&gt;
      &lt;td&gt;✖&lt;/td&gt;
      &lt;td&gt;✖&lt;/td&gt;
      &lt;td&gt;✔&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;可串行化（Serializable）&lt;/td&gt;
      &lt;td&gt;✖&lt;/td&gt;
      &lt;td&gt;✖&lt;/td&gt;
      &lt;td&gt;✖&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h2 id=&quot;锁机制&quot;&gt;锁机制&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;共享锁和排它锁&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;共享锁：由读表操作加上的锁，加锁后其他用户只能获取该表或行的共享锁，不能获取排它锁，也就是说只能读不能写。&lt;/li&gt;
      &lt;li&gt;排它锁：由写表操作加上的锁，加锁后其他用户不能获取该表或行的任何锁，典型是MySQL事务中的&lt;code class=&quot;highlighter-rouge&quot;&gt;for update&lt;/code&gt;。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;行锁和表锁&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;行锁：对某行记录加上锁&lt;/li&gt;
      &lt;li&gt;表锁：对整个表加上锁&lt;/li&gt;
    &lt;/ul&gt;

    &lt;p&gt;这样组合起来有：行级共享锁，表级共享锁，行级排它锁，表级排它锁。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;乐观锁、悲观锁&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;
        &lt;p&gt;悲观锁（Pessimistic Lock）&lt;/p&gt;

        &lt;p&gt;顾名思义，就是很悲观，每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人拿这个数据就会block直到它拿到锁。&lt;/p&gt;

        &lt;p&gt;传统的关系型数据库里边就用到了很多这种锁机制，比如行锁，表锁，读锁，写锁等，都是在做操作之前先上锁。&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;乐观锁（Optimistic Lock）&lt;/p&gt;

        &lt;p&gt;顾名思义，就是很乐观，每次去拿数据的时候都认为别人不会修改，所以不会上锁。但是在更新数据的时候会判断一下在此期间别人有没有去更新这个数据，如果期间被修改，则给用户做出提示。可以使用版本号机制记录状态。&lt;/p&gt;

        &lt;p&gt;乐观锁适用于多读的应用类型，这样可以提高吞吐量，想数据库如果提供类似于write_condition机制的其实都是提供的乐观锁。&lt;/p&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;</content><author><name>郝强</name></author><category term="resources" /><category term="db" /><summary type="html">数据库四大特性</summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="http://localhost:4000/db-transaction-0.jpeg" /></entry></feed>